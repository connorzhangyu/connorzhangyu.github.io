<!doctype html><html lang=zh><head><title>exception :: Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="异常 throw 和 throws 的区别？ throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。
final、finally、finalize 有什么区别？ final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。
try-catch-finally 中哪个部分可以省略？ catch 可以省略
原因：
更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。
理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。
至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。
try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？ 会执行，在 return 前执行。
代码示例1：
/* * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？ */ public class FinallyDemo2 { public static void main(String[] args) { System.out.println(getInt()); } public static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; /* * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30 */ } finally { a = 40; } // return a; } } 执行结果：30
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=../../posts/exception/><link rel=stylesheet href=../../styles.css><link rel="shortcut icon" href=../../img/theme-colors/orange.png><link rel=apple-touch-icon href=../../img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Connor"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="og:title" content="exception"><meta property="og:description" content="异常 throw 和 throws 的区别？ throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。
final、finally、finalize 有什么区别？ final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。
try-catch-finally 中哪个部分可以省略？ catch 可以省略
原因：
更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。
理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。
至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。
try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？ 会执行，在 return 前执行。
代码示例1：
/* * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？ */ public class FinallyDemo2 { public static void main(String[] args) { System.out.println(getInt()); } public static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; /* * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30 */ } finally { a = 40; } // return a; } } 执行结果：30
"><meta property="og:url" content="/posts/exception/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="/"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-01-04 04:08:55 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=../../><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=../../posts/exception/>exception</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><div><h1 id=异常>异常<a href=#异常 class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=throw-和-throws-的区别>throw 和 throws 的区别？<a href=#throw-和-throws-的区别 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。</p><h2 id=finalfinallyfinalize-有什么区别>final、finally、finalize 有什么区别？<a href=#finalfinallyfinalize-有什么区别 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。</p><h2 id=try-catch-finally-中哪个部分可以省略>try-catch-finally 中哪个部分可以省略？<a href=#try-catch-finally-中哪个部分可以省略 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>catch 可以省略<br>原因：<br>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。<br>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。<br>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p><h2 id=try-catch-finally-中如果-catch-中-return-了finally-还会执行吗>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？<a href=#try-catch-finally-中如果-catch-中-return-了finally-还会执行吗 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>会执行，在 return 前执行。<br>代码示例1：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FinallyDemo2</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getInt());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getInt</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> 10;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(a <span style=color:#f92672>/</span> 0);
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 20;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (ArithmeticException e) {
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 30;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>            <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
</span></span></span><span style=display:flex><span><span style=color:#75715e>             */</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 40;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>//      return a;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行结果：30</p><p>代码示例2：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.java_02;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FinallyDemo2</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getInt());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getInt</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> 10;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(a <span style=color:#f92672>/</span> 0);
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 20;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (ArithmeticException e) {
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 30;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>            <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
</span></span></span><span style=display:flex><span><span style=color:#75715e>             */</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 40;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> a; <span style=color:#75715e>//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//      return a;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行结果：40</p><h2 id=常见的异常类有哪些>常见的异常类有哪些？<a href=#常见的异常类有哪些 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。<br>SQLException：提供关于数据库访问错误或其他错误信息的异常。<br>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。<br>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。<br>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。<br>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。<br>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。<br>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。<br>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。<br>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。<br>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。<br>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。<br>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。<br>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。<br>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</p><h2 id=目录>目录<a href=#目录 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><a href=../../java/javaBase.md>Java基础</a></li><li><a href=../../java/collection.md>容器</a></li><li><a href=../../java/thread.md>线程</a></li><li><a href=../../java/reflection.md>反射</a></li><li><a href=../../java/cloneable.md>对象克隆</a></li><li><a href=../../java/javaWeb.md>JavaWeb</a></li><li><a href=../../java/exception.md>异常</a></li><li><a href=../../java/netWork.md>网络服务</a></li><li><a href=../../java/designpattern.md>设计模式</a></li><li><a href=../../java/spring.md>Spring</a></li><li><a href=../../java/springMVC.md>Spring MVC</a></li><li><a href=../../java/springBoot.md>Spring Boot</a></li><li><a href=../../java/springCloud.md>Spring Cloud</a></li><li><a href=../../java/hibernate.md>Hibernate</a></li><li><a href=../../java/mybatis.md>Mybatis</a></li><li><a href=../../java/mq.md>队列</a></li><li><a href=../../java/zookeeper.md>Zookeeper</a></li><li><a href=../../java/mySql.md>MySql</a></li><li><a href=../../java/redis.md>Redis</a></li><li><a href=../../java/jvm.md>Jvm</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=../../posts/designpattern/><span class=button__icon>←</span>
<span class=button__text>designpattern</span>
</a></span><span class="button next"><a href=../../posts/hibernate/><span class=button__text>hibernate</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=../../bundle.min.js></script></div></body></html>