<!doctype html><html lang=zh><head><title>Redis :: Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="安装Redis 安装单机Redis {% tabs 安装单机Redis %}
Releases · tporadowski/redis
docker run \ -p 6379:6379 \ --name myredis \ -v $PWD/redis.conf:/etc/redis/redis.conf \ -v $PWD/data:/data \ -d redis:3.2 redis-server /etc/redis/redis.conf \ --restart=always \ --appendonly yes 命令说明：
-name myredis : 指定容器名称，这个最好加上，不然在看docker进程的时候会很尴尬。 p 6699:6379 ： 端口映射，默认redis启动的是6379,外部端口(6699)。 v $PWD/redis.conf:/etc/redis/redis.conf ： 将主机中当前目录下的redis.conf配置文件映射。 v $PWD/data:/data -d redis:latest： 将主机中当前目录下的data挂载到容器的/data -redis-server --appendonly yes :在容器执行redis-server启动命令，并打开redis持久化配置 -restart=always:自动启动 注意事项： 如果不需要指定配置，v $PWD/redis.conf:/etc/redis/redis.conf 可以不用 redis-server 后面的那段 /etc/redis/redis.conf 也可以不用。 $PWD 在window系统下貌似不能用,可以用相对路径/ 客户端连接
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://connorzhangyu.com/posts/redis/><link rel=stylesheet href=https://connorzhangyu.com/styles.css><link rel="shortcut icon" href=https://connorzhangyu.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://connorzhangyu.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Anthony"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="og:title" content="Redis"><meta property="og:description" content="安装Redis 安装单机Redis {% tabs 安装单机Redis %}
Releases · tporadowski/redis
docker run \ -p 6379:6379 \ --name myredis \ -v $PWD/redis.conf:/etc/redis/redis.conf \ -v $PWD/data:/data \ -d redis:3.2 redis-server /etc/redis/redis.conf \ --restart=always \ --appendonly yes 命令说明：
-name myredis : 指定容器名称，这个最好加上，不然在看docker进程的时候会很尴尬。 p 6699:6379 ： 端口映射，默认redis启动的是6379,外部端口(6699)。 v $PWD/redis.conf:/etc/redis/redis.conf ： 将主机中当前目录下的redis.conf配置文件映射。 v $PWD/data:/data -d redis:latest： 将主机中当前目录下的data挂载到容器的/data -redis-server --appendonly yes :在容器执行redis-server启动命令，并打开redis持久化配置 -restart=always:自动启动 注意事项： 如果不需要指定配置，v $PWD/redis.conf:/etc/redis/redis.conf 可以不用 redis-server 后面的那段 /etc/redis/redis.conf 也可以不用。 $PWD 在window系统下貌似不能用,可以用相对路径/ 客户端连接
"><meta property="og:url" content="https://connorzhangyu.com/posts/redis/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="https://image.runtimes.cc/202404051532701.jpg"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="Linux"><meta property="article:published_time" content="2022-11-19 18:25:00 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://connorzhangyu.com/posts/redis/>Redis</a></h1><div class=post-meta><time class=post-date>2022-11-19</time><span class=post-author>Anthony</span></div><span class=post-tags>#<a href=https://connorzhangyu.com/tags/redis/>Redis</a>&nbsp;
</span><img src=https://image.runtimes.cc/202404051532701.jpg class=post-cover alt=" " title="Cover Image"><div class=post-content><div><h1 id=安装redis>安装Redis<a href=#安装redis class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=安装单机redis>安装单机Redis<a href=#安装单机redis class=hanchor arialabel=Anchor>&#8983;</a></h2><p>{% tabs 安装单机Redis %}</p><p><a href=https://github.com/tporadowski/redis/releases>Releases · tporadowski/redis</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>       -p 6379:6379 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>       --name myredis <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>       -v $PWD/redis.conf:/etc/redis/redis.conf <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>       -v $PWD/data:/data <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>       -d redis:3.2 redis-server /etc/redis/redis.conf <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>       --restart<span style=color:#f92672>=</span>always <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>       --appendonly yes
</span></span></code></pre></div><p>命令说明：</p><ul><li><code>-name myredis</code> : 指定容器名称，这个最好加上，不然在看docker进程的时候会很尴尬。</li><li><code>p 6699:6379</code> ： 端口映射，默认redis启动的是6379,外部端口(6699)。</li><li><code>v $PWD/redis.conf:/etc/redis/redis.conf</code> ： 将主机中当前目录下的redis.conf配置文件映射。</li><li><code>v $PWD/data:/data -d redis:latest</code>： 将主机中当前目录下的data挂载到容器的/data</li><li><code>-redis-server --appendonly yes</code> :在容器执行redis-server启动命令，并打开redis持久化配置</li><li><code>-restart=always</code>:自动启动</li><li>注意事项：</li><li>如果不需要指定配置，<code>v $PWD/redis.conf:/etc/redis/redis.conf</code> 可以不用</li><li>redis-server 后面的那段 <code>/etc/redis/redis.conf</code> 也可以不用。</li><li><code>$PWD</code> 在window系统下貌似不能用,可以用相对路径<code>/</code></li></ul><p>客户端连接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 先查询到myredis容器的ip地址。</span>
</span></span><span style=display:flex><span>docker inspect myredis | grep IP
</span></span><span style=display:flex><span><span style=color:#75715e># 连接到redis容器。然后就进入redis命令行了。</span>
</span></span><span style=display:flex><span>docker run -it redis:latest redis-cli -h 192.168.42.32
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Cetnos安装需要的软件</span>
</span></span><span style=display:flex><span>yum -y install gcc gcc-c++ kernel-devel make
</span></span><span style=display:flex><span><span style=color:#75715e># Ubunt 安装需要的软件</span>
</span></span><span style=display:flex><span>sudo apt install gcc g++ make linux-kernel-headers kernel-package
</span></span><span style=display:flex><span><span style=color:#75715e># ubuntu 新内核版本要用到的</span>
</span></span><span style=display:flex><span>sudo apt install gcc g++ make linux-libc-dev
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 下载redis</span>
</span></span><span style=display:flex><span>wget http://download.redis.io/releases/redis-5.0.5.tar.gz
</span></span><span style=display:flex><span>tar -zxvf redis-5.0.5.tar.gz
</span></span><span style=display:flex><span>cd redis-5.0.5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 安装redis</span>
</span></span><span style=display:flex><span>sudo make <span style=color:#f92672>&amp;&amp;</span> make instal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 注意make的时候可能会报错: #include &lt;jemalloc/jemalloc.h&gt;,使用下面的命令</span>
</span></span><span style=display:flex><span>make MALLOC<span style=color:#f92672>=</span>libc
</span></span></code></pre></div><p>修改redis.cnf</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 设置后台运行</span>
</span></span><span style=display:flex><span>daemonize yes
</span></span><span style=display:flex><span><span style=color:#75715e># 设置log文件路径</span>
</span></span><span style=display:flex><span>logfile /var/log/redis/redis-server.log
</span></span><span style=display:flex><span><span style=color:#75715e># 设置持久化文件存放路径</span>
</span></span><span style=display:flex><span>dir /var/lib/redis
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 创建日志存放目录</span>
</span></span><span style=display:flex><span>mkdir /var/log/redis/
</span></span><span style=display:flex><span><span style=color:#75715e># 创建持久化文件存放目录</span>
</span></span><span style=display:flex><span>mkdir /var/log/redis/
</span></span><span style=display:flex><span><span style=color:#75715e># 创建存放配置的文件夹</span>
</span></span><span style=display:flex><span>mkdir /etc/redis
</span></span><span style=display:flex><span><span style=color:#75715e># 拷贝配置文件并改名</span>
</span></span><span style=display:flex><span>cp redis.conf /etc/redis/6379.conf
</span></span><span style=display:flex><span><span style=color:#75715e># 拷贝自启动脚本文件</span>
</span></span><span style=display:flex><span>cp /usr/local/redis-6.0.3/utils/redis_init_script /etc/init.d/redisd
</span></span></code></pre></div><ul><li>将启动脚本复制到<code>/etc/init.d</code>目录下，本例将启动脚本命名为redisd（通常都以d结尾表示是后台自启动服务）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Centos</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#设置为开机自启动服务器</span>
</span></span><span style=display:flex><span>cd /etc/init.d/
</span></span><span style=display:flex><span>chkconfig redisd on
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Ubuntu</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#设置服务脚本有执行权限</span>
</span></span><span style=display:flex><span>sudo chmod +x /etc/init.d/redisd
</span></span><span style=display:flex><span><span style=color:#75715e>#注册服务</span>
</span></span><span style=display:flex><span>cd /etc/init.d/
</span></span><span style=display:flex><span>sudo update-rc.d redisd defaults
</span></span></code></pre></div><ul><li>此处直接配置开启自启动 <code>chkconfig redisd on</code> 将报错误： <code>service does not support chkconfig</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e># chkconfig:   2345 90 10</span>
</span></span><span style=display:flex><span><span style=color:#75715e># description:  Redis is a persistent key-value database</span>
</span></span></code></pre></div><p>通用命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#启动Redis服务</span>
</span></span><span style=display:flex><span>sudo service redisd start
</span></span><span style=display:flex><span><span style=color:#75715e>#关闭服务</span>
</span></span><span style=display:flex><span>sudo service redisd stop
</span></span><span style=display:flex><span><span style=color:#75715e>#重启服务：</span>
</span></span><span style=display:flex><span>sudo service redisd restart
</span></span></code></pre></div><p>{% endtabs %}</p><h2 id=安装集群redis>安装集群Redis<a href=#安装集群redis class=hanchor arialabel=Anchor>&#8983;</a></h2><p>{% tabs 安装集群Redis %}</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>echo <span style=color:#e6db74>&#34;start install redis-cluster...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> ! -d /opt/docker-redis/7001/ <span style=color:#f92672>]</span>;<span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>	mkdir -p /opt/docker-redis/700<span style=color:#f92672>{</span>1,2,3,4,5,6<span style=color:#f92672>}</span>/data/
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>cd /opt/docker-redis/7001/
</span></span><span style=display:flex><span>wget http://download.redis.io/redis-stable/redis.conf -O /opt/docker-redis/7001/redis7001.conf
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>sed -i <span style=color:#e6db74>&#39;/^#/d;/^$/d&#39;</span> redis7001.conf  <span style=color:#75715e>#取出空行和注释行</span>
</span></span><span style=display:flex><span>sed -i <span style=color:#e6db74>&#39;s/bind/#bind/g;s/appendonly no/appendonly yes/g;s/protected-mode yes/protected-mode no/g&#39;</span> redis7001.conf  <span style=color:#75715e>#开启持久化，注释监听ip</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;#集群配置&#39;</span> &gt;&gt; /opt/docker-redis/7001/redis7001.conf
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;cluster-enabled yes&#39;</span> &gt;&gt;/opt/docker-redis/7001/redis7001.conf
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;cluster-config-file nodes-7001.conf&#39;</span> &gt;&gt;/opt/docker-redis/7001/redis7001.conf
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;cluster-node-timeout 15000&#39;</span> &gt;&gt;/opt/docker-redis/7001/redis7001.conf
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;cluster-announce-ip 192.168.92.135&#39;</span> &gt;&gt;/opt/docker-redis/7001/redis7001.conf
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;cluster-announce-port 7001&#39;</span> &gt;&gt;/opt/docker-redis/7001/redis7001.conf
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;cluster-announce-bus-port 17001&#39;</span> &gt;&gt;/opt/docker-redis/7001/redis7001.conf
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> port in <span style=color:#e6db74>`</span>seq <span style=color:#ae81ff>7002</span> 7006<span style=color:#e6db74>`</span>;<span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>	cp redis7001.conf ../<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/redis<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>.conf
</span></span><span style=display:flex><span>	echo <span style=color:#e6db74>&#34;cluster-config-file nodes-</span><span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span><span style=color:#e6db74>.conf&#34;</span> &gt;&gt;/opt/docker-redis/<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/redis<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>.conf
</span></span><span style=display:flex><span>	echo <span style=color:#e6db74>&#34;cluster-announce-port </span><span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> &gt;&gt;/opt/docker-redis/<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/redis<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>.conf
</span></span><span style=display:flex><span>	echo <span style=color:#e6db74>&#34;cluster-announce-bus-port 1</span><span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> &gt;&gt;/opt/docker-redis/<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/redis<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>.conf
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> port in <span style=color:#e6db74>`</span>seq <span style=color:#ae81ff>7001</span> 7006<span style=color:#e6db74>`</span>;<span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	sed -i &#34;s/logfile \&#34;\&#34;/logfile \&#34;\/usr\/local\/docker\/redis-cluster\/log\/redis.log\&#34;/g&#34; redis${port}.conf</span>
</span></span><span style=display:flex><span>	sed -i <span style=color:#e6db74>&#34;s/port 6379/port </span><span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span><span style=color:#e6db74>/g&#34;</span> /opt/docker-redis/<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/redis<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>.conf
</span></span><span style=display:flex><span>	docker run --restart always --name redis-cluster-<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span> --net host --privileged<span style=color:#f92672>=</span>true -v /opt/docker-redis/<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/redis<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>.conf:/usr/local/docker/redis-cluster/<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/redis<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>.conf -v  <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	/opt/docker-redis/<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/data/:/usr/local/docker/redis-cluster/data/ <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	-d redis redis-server /usr/local/docker/redis-cluster/<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/redis<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>.conf
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>docker ps
</span></span><span style=display:flex><span>sleep 2s
</span></span><span style=display:flex><span>ss -tnulp|grep redis
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#创建集群</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#redis-cli  --cluster create 192.168.92.135:7001 192.168.92.135:7002 192.168.92.135:7003 192.168.92.135:7004 192.168.92.135:7005 192.168.92.135:7006  --cluster-replicas 1</span>
</span></span></code></pre></div><p><strong>下载,解压,编译安装</strong></p><ul><li>用一台虚拟机模拟6个节点，创建出3 master、3 salve 环境。</li><li>创建文件前,先编译好Redis程序</li></ul><p><strong>创建节点</strong>
创建配置redis.conf</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 端口7000 7001 7002 7003 7004 7005</span>
</span></span><span style=display:flex><span>port  <span style=color:#ae81ff>7000</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 自己建议修改为0.0.0.0</span>
</span></span><span style=display:flex><span>bind 0.0.0.0
</span></span><span style=display:flex><span><span style=color:#75715e># redis后台运行</span>
</span></span><span style=display:flex><span>daemonize yes
</span></span><span style=display:flex><span><span style=color:#75715e># pidfile文件对应7000 7001 7002 7003 7004 7005</span>
</span></span><span style=display:flex><span>pidfile  /var/run/redis_7000.pid
</span></span><span style=display:flex><span><span style=color:#75715e># 开启集群  把注释#去掉</span>
</span></span><span style=display:flex><span>cluster-enabled  yes
</span></span><span style=display:flex><span><span style=color:#75715e># 集群的配置,配置文件首次启动自动生成7000 7001 7002 7003 7004 7005</span>
</span></span><span style=display:flex><span>cluster-config-file  nodes_7000.conf
</span></span><span style=display:flex><span><span style=color:#75715e># 请求超时  默认15秒，可自行设置</span>
</span></span><span style=display:flex><span>cluster-node-timeout  <span style=color:#ae81ff>15000</span>
</span></span><span style=display:flex><span><span style=color:#75715e># AOF日志开启</span>
</span></span><span style=display:flex><span>appendonly  yes
</span></span></code></pre></div><p>创建文件夹</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cd /usr/local
</span></span><span style=display:flex><span>mkdir redis_cluster
</span></span><span style=display:flex><span>cd redis_cluster
</span></span><span style=display:flex><span>mkdir <span style=color:#ae81ff>7000</span> <span style=color:#ae81ff>7001</span> <span style=color:#ae81ff>7002</span> <span style=color:#ae81ff>7003</span> <span style=color:#ae81ff>7004</span> <span style=color:#ae81ff>7005</span>
</span></span><span style=display:flex><span>cp /usr/local/redis-5.0.5/redis.conf /usr/local/redis_cluster/7000/
</span></span><span style=display:flex><span>cp /usr/local/redis-5.0.5/redis.conf /usr/local/redis_cluster/7001/
</span></span><span style=display:flex><span>cp /usr/local/redis-5.0.5/redis.conf /usr/local/redis_cluster/7002/
</span></span><span style=display:flex><span>cp /usr/local/redis-5.0.5/redis.conf /usr/local/redis_cluster/7003/
</span></span><span style=display:flex><span>cp /usr/local/redis-5.0.5/redis.conf /usr/local/redis_cluster/7004/
</span></span><span style=display:flex><span>cp /usr/local/redis-5.0.5/redis.conf /usr/local/redis_cluster/7005/
</span></span></code></pre></div><p>分别修改三个文件夹里的配置文件,修改如下内容</p><p>启动节点的redis<code>/usr/local/bin/redis-server</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/usr/local/bin/redis-server /usr/local/redis_cluster/7000/redis.conf
</span></span><span style=display:flex><span>/usr/local/bin/redis-server /usr/local/redis_cluster/7001/redis.conf
</span></span><span style=display:flex><span>/usr/local/bin/redis-server /usr/local/redis_cluster/7002/redis.conf
</span></span><span style=display:flex><span>/usr/local/bin/redis-server /usr/local/redis_cluster/7003/redis.conf
</span></span><span style=display:flex><span>/usr/local/bin/redis-server /usr/local/redis_cluster/7004/redis.conf
</span></span><span style=display:flex><span>/usr/local/bin/redis-server /usr/local/redis_cluster/7005/redis.conf
</span></span></code></pre></div><p>检查 redis 启动情况</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps -ef | grep redi
</span></span><span style=display:flex><span>root      <span style=color:#ae81ff>61020</span>      <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>0</span> 02:14 ?        00:00:01 redis-server 0.0.0.0:7000 <span style=color:#f92672>[</span>cluster<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>root      <span style=color:#ae81ff>61024</span>      <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>0</span> 02:14 ?        00:00:01 redis-server 0.0.0.0:7001 <span style=color:#f92672>[</span>cluster<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>root      <span style=color:#ae81ff>61029</span>      <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>0</span> 02:14 ?        00:00:01 redis-server 0.0.0.0:7002 <span style=color:#f92672>[</span>cluster<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>root      <span style=color:#ae81ff>61029</span>      <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>0</span> 02:14 ?        00:00:01 redis-server 0.0.0.0:7002 <span style=color:#f92672>[</span>cluster<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>root      <span style=color:#ae81ff>61029</span>      <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>0</span> 02:14 ?        00:00:01 redis-server 0.0.0.0:7002 <span style=color:#f92672>[</span>cluster<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>root      <span style=color:#ae81ff>61029</span>      <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>0</span> 02:14 ?        00:00:01 redis-server 0.0.0.0:7002 <span style=color:#f92672>[</span>cluster<span style=color:#f92672>]</span>
</span></span></code></pre></div><p><strong>启动集群</strong></p><ul><li>装的redis是5.x的版本,这里没有应用到<code>redis-trib.rb</code>,所以就不需要装ruby</li><li>这里启动的时候可能会有报错,因为默认开启了<code>protected-mode</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cd /usr/local/bin
</span></span><span style=display:flex><span>redis-cli --cluster create 192.168.0.100:7003 192.168.0.100:7004 192.168.0.100:7005 192.168.0.179:7000 192.168.0.179:7001 192.168.0.179:7002 --cluster-replicas <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Can I set the above configuration? <span style=color:#f92672>(</span>type <span style=color:#e6db74>&#39;yes&#39;</span> to accept<span style=color:#f92672>)</span>: yes
</span></span><span style=display:flex><span>yes
</span></span></code></pre></div><p><strong>校验,等运行完成</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@worker1 src<span style=color:#f92672>]</span><span style=color:#75715e># redis-cli --cluster check 192.168.0.179:7000</span>
</span></span><span style=display:flex><span>192.168.0.179:7000 <span style=color:#f92672>(</span>27bce53b...<span style=color:#f92672>)</span> -&gt; <span style=color:#ae81ff>0</span> keys | <span style=color:#ae81ff>5462</span> slots | <span style=color:#ae81ff>1</span> slaves.
</span></span><span style=display:flex><span>192.168.0.100:7004 <span style=color:#f92672>(</span>6b0173d9...<span style=color:#f92672>)</span> -&gt; <span style=color:#ae81ff>0</span> keys | <span style=color:#ae81ff>5461</span> slots | <span style=color:#ae81ff>1</span> slaves.
</span></span><span style=display:flex><span>192.168.0.100:7003 <span style=color:#f92672>(</span>9f15a932...<span style=color:#f92672>)</span> -&gt; <span style=color:#ae81ff>0</span> keys | <span style=color:#ae81ff>5461</span> slots | <span style=color:#ae81ff>1</span> slaves.
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>OK<span style=color:#f92672>]</span> <span style=color:#ae81ff>0</span> keys in <span style=color:#ae81ff>3</span> masters.
</span></span><span style=display:flex><span>0.00 keys per slot on average.
</span></span><span style=display:flex><span>&gt;&gt;&gt; Performing Cluster Check <span style=color:#f92672>(</span>using node 192.168.0.179:7000<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>M: 27bce53bda92341ca4a5c82c2361ab99f24c0b27 192.168.0.179:7000
</span></span><span style=display:flex><span>   slots:<span style=color:#f92672>[</span>5461-10922<span style=color:#f92672>]</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>5462</span> slots<span style=color:#f92672>)</span> master
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>1</span> additional replica<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>S: c7ebcd900fb7d9afb1980797acba45518cb7d877 192.168.0.100:7005
</span></span><span style=display:flex><span>   slots: <span style=color:#f92672>(</span><span style=color:#ae81ff>0</span> slots<span style=color:#f92672>)</span> slave
</span></span><span style=display:flex><span>   replicates 27bce53bda92341ca4a5c82c2361ab99f24c0b27
</span></span><span style=display:flex><span>S: ed5256f8db1bf556a8dadbe8f2b07699507e17d9 192.168.0.179:7001
</span></span><span style=display:flex><span>   slots: <span style=color:#f92672>(</span><span style=color:#ae81ff>0</span> slots<span style=color:#f92672>)</span> slave
</span></span><span style=display:flex><span>   replicates 6b0173d925f70807a9081b7bc09bcd37be857342
</span></span><span style=display:flex><span>S: 758609eaea88bac25b864f2badbab2171a68089b 192.168.0.179:7002
</span></span><span style=display:flex><span>   slots: <span style=color:#f92672>(</span><span style=color:#ae81ff>0</span> slots<span style=color:#f92672>)</span> slave
</span></span><span style=display:flex><span>   replicates 9f15a9329a9d0ec5c7fcb5abbba817730f0942f9
</span></span><span style=display:flex><span>M: 6b0173d925f70807a9081b7bc09bcd37be857342 192.168.0.100:7004
</span></span><span style=display:flex><span>   slots:<span style=color:#f92672>[</span>10923-16383<span style=color:#f92672>]</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>5461</span> slots<span style=color:#f92672>)</span> master
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>1</span> additional replica<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>M: 9f15a9329a9d0ec5c7fcb5abbba817730f0942f9 192.168.0.100:7003
</span></span><span style=display:flex><span>   slots:<span style=color:#f92672>[</span>0-5460<span style=color:#f92672>]</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>5461</span> slots<span style=color:#f92672>)</span> master
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>1</span> additional replica<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>OK<span style=color:#f92672>]</span> All nodes agree about slots configuration.
</span></span><span style=display:flex><span>&gt;&gt;&gt; Check <span style=color:#66d9ef>for</span> open slots...
</span></span><span style=display:flex><span>&gt;&gt;&gt; Check slots coverage...
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>OK<span style=color:#f92672>]</span> All <span style=color:#ae81ff>16384</span> slots covered.
</span></span></code></pre></div><p><strong>Cluster配置</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 设置加入cluster，成为其中的节点</span>
</span></span><span style=display:flex><span>cluster-enabled yes|no
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</span>
</span></span><span style=display:flex><span>cluster-config-file &lt; filename&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</span>
</span></span><span style=display:flex><span>cluster-node-timeout &lt; milliseconds&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># master连接的slave最小数量</span>
</span></span><span style=display:flex><span>cluster-migration-barrier &lt; count&gt;
</span></span></code></pre></div><p><strong>Cluster节点操作命令</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 连接到集群,加一个-c就行</span>
</span></span><span style=display:flex><span>redis-cli -c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看集群节点信息</span>
</span></span><span style=display:flex><span>cluster nodes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 进入一个从节点redis，切换其主节点</span>
</span></span><span style=display:flex><span>cluster replication &lt;master-id&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 发现一个新节点，新增主节点</span>
</span></span><span style=display:flex><span>cluster meet ip:port
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 忽略一个没有solt的节点</span>
</span></span><span style=display:flex><span>cluster forget
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 手动故障转移</span>
</span></span><span style=display:flex><span>cluster failover
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 计算键 key 应该被放置在哪个槽上</span>
</span></span><span style=display:flex><span>cluster keyslot &lt;key&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回槽 slot 目前包含的键值对数量</span>
</span></span><span style=display:flex><span>cluster countkeysinslot &lt;slot&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回 count 个 slot 槽中的键</span>
</span></span><span style=display:flex><span>cluster getkeysinslot &lt;slot&gt; &lt;count&gt;
</span></span></code></pre></div><p>{% endtabs %}</p><h2 id=配置>配置<a href=#配置 class=hanchor arialabel=Anchor>&#8983;</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># requirepass foobared 注释去掉并写入要设置的密码 , 需要重启:systemctl restart redis</span>
</span></span><span style=display:flex><span>requirepass <span style=color:#ae81ff>123456</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将 bind 设置为允许所有 IP 地址的远程访问,需要重启:systemctl restart redis</span>
</span></span><span style=display:flex><span>bind 0.0.0.0
</span></span></code></pre></div><h1 id=redis的数据类型>Redis的数据类型<a href=#redis的数据类型 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>redis自身是一个Map,其中所有的数据都是采用key:value的形式存储</p><p>数据类型指的是存储的数据的类型，也就是value部分的类型，key部分永远都是字符串</p><ul><li>string &ndash;> String</li><li>hash &ndash;> Hashmap</li><li>list &ndash;> LinkList</li><li>set &ndash;> HashSet</li><li>sorted_set &ndash;> TreeSet</li></ul><h2 id=string>String<a href=#string class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 设值</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 格式 set &lt;key&gt; &lt;value&gt;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;set k1 anthony
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;OK&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 取值</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 格式 get &lt;key&gt;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;get k1
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;anthony&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 删除值,成功返回1,不成功返回0</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;del k1
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;del k1234
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;0&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 一次性存入多个值</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;mset k1 v1 k2 v2 k3 v3
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;OK&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 一次性取出多个值</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;mget k1 k2 k3
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;v1&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;v2&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;v3&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 打印值的长度</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;set name anthony
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;OK&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;get name
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;anthony&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;strlen name
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;7&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 追加</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 有数据就追加</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;append name <span style=color:#ae81ff>666</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;10&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;get name
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;anthony666&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 没数据就新建</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;append othername frankie
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;7&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;get othername
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;frankie&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 递增递减,小数不行</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;set num <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;OK&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;incr num
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;2&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;incr num
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;decr num
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;2&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;decr num
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 递增递减指定值,小数不行</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;incrby num <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;6&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;decrby num <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;4&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 小数不行</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;incrby num 1.5
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;ERR value is not an integer or out of range&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 递增指定小数,貌似没有递减</span>
</span></span><span style=display:flex><span>192.168.245.129:1&gt;incrbyfloat num 1.5
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;5.5&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 指定过期时间</span>
</span></span><span style=display:flex><span><span style=color:#75715e># EX 用于指定 key 的过期时间。EX(秒),PX(毫秒),KEEPTTL 保持原有的过期时间不变。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># PX 毫秒-设置指定的到期时间（以毫秒为单位）。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># NX 没有key的时候才能set成功,XX key存在的时候才能set成功</span>
</span></span><span style=display:flex><span>SET key value <span style=color:#f92672>[</span>EX seconds|PX milliseconds|KEEPTTL<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>NX|XX<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>GET<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 指定过期时间</span>
</span></span><span style=display:flex><span><span style=color:#75715e># time,以秒为单位。</span>
</span></span><span style=display:flex><span>SETEX key time value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 功能等价NX,  SET if Not eXists</span>
</span></span><span style=display:flex><span>redis&gt; SETNX mykey <span style=color:#e6db74>&#34;Hello&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>redis&gt; SETNX mykey <span style=color:#e6db74>&#34;World&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><h2 id=hash>Hash<a href=#hash class=hanchor arialabel=Anchor>&#8983;</a></h2><p>{% mermaid %}</p><p>graph LR;
Key;
Key&ndash;>Field1&ndash;> Value1;
Key&ndash;>Field2&ndash;> Value2;
Key&ndash;>Field3&ndash;> Value3;
subgraph 相当于Value<br>Field1;
Value1;
Field2;
Value2;
Field3;
Value3;
end;</p><p>{% endmermaid %}</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 设值/修改值  hset key filed1 value</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;HSET user name zhangsan
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;hset user age <span style=color:#ae81ff>38</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 取一个属性值</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;hget user age
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;38&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 取多个属性值</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;hmget user age name
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;45&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;zhangsan&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 取一个key</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;hgetall user
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;name&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;zhangsan&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;age&#34;</span>
</span></span><span style=display:flex><span> 4<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;38&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e># 删除一个属性值</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;hdel user name
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;hgetall user
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;age&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;38&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e># 查看有多少个属性</span>
</span></span><span style=display:flex><span> 192.168.245.129:0&gt;hlen user
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取所有的属性</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;hkeys user
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;age&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;name&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;sex&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取所有的属性值</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;hvals user
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;45&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;zhangsan&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;n&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e># 指定属性增加指定值</span>
</span></span><span style=display:flex><span> 192.168.245.129:0&gt;hincrby user age <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;46&#34;</span>
</span></span></code></pre></div><h2 id=list>List<a href=#list class=hanchor arialabel=Anchor>&#8983;</a></h2><p>{% mermaid %}
flowchart LR</p><p>subgraph 顺序表/数组
id0(头指针)
id1[华为]
id2(苹果)
id3(微软)
end</p><p>subgraph 单向链表
direction LR
id00[头指针] &ndash;> id4[[华为]]
id4[[华为]] &ndash;> id5[[苹果]]
id5[[苹果]] &ndash;> id6[[微软]]
end
subgraph 双向链表
direction LR
id000[头指针] &lt;&ndash;> id7[[华为]]
id7[[华为]] &lt;&ndash;> id8[[苹果]]
id8[[苹果]] &lt;&ndash;> id9[[微软]]
end</p><p>{% endmermaid %}</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 先插入huawei</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lpush list1 huawei
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 再插入apple</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lpush list1 apple
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;2&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 最后插入Microsoft</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lpush list1 microsoft
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 从左边取</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lrange list1 <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;microsoft&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;apple&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;huawei&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e># 一次性插入多条数据</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;rpush list2 a b c
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  从左边取</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lrange key start stop</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lindex key index 取指定索引的值</span>
</span></span><span style=display:flex><span><span style=color:#75715e># llen key 取长度</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 没有rrange</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lrange list2 <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;a&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;b&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;c&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#75715e># 从左边取的第二钟方法</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lrange list2 <span style=color:#ae81ff>0</span> -1
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;a&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;b&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;c&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># lpop从左边删,rpop从右边删</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lpush list3 a b c
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lpop list3
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;c&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>----------------------------------------------------------------------------------------------------
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 阻塞取值,从运行命令开始,如果有数据,取出来,立马返回,如果没有数据,就等指定的时间20s,有就立马返回结束,如果没有,就一直等到时间结束</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;blpop list4 <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;list4&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;32&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 删除指定数据</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lrem key count value</span>
</span></span><span style=display:flex><span><span style=color:#75715e># count是删除多少个value</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lpush dianzan  a b c d
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;4&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lrem dianzan <span style=color:#ae81ff>1</span> c
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;lrange dianzan <span style=color:#ae81ff>0</span> -1
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;d&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;b&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;a&#34;</span>
</span></span></code></pre></div><h2 id=set>Set<a href=#set class=hanchor arialabel=Anchor>&#8983;</a></h2><p><img src=https://image.runtimes.cc/202404051516451.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 添加</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;sadd users zs
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;sadd users lisi
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;sadd users ww
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查列表</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;smembers users
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;lisi&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;ww&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;zs&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e># 查数量</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;scard users
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 判断是否有指定数据</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;sismember users ls
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;0&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;sismember users ww
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;smembers users
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;lisi&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;ww&#34;</span>
</span></span><span style=display:flex><span> 3<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;zs&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e># 删除指定数据</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;srem users ww
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>192.168.245.129:0&gt;smembers users
</span></span><span style=display:flex><span> 1<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;lisi&#34;</span>
</span></span><span style=display:flex><span> 2<span style=color:#f92672>)</span>  <span style=color:#e6db74>&#34;zs&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e># 随机获取集合中指定数量的数据,获取之后,原来的队列数据不变</span>
</span></span><span style=display:flex><span> srandmember key count
</span></span><span style=display:flex><span> <span style=color:#75715e># 随机获取集合中的某个数据并讲该数据移除集合</span>
</span></span><span style=display:flex><span> spop key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> --------------------------------------------------------------------------------------
</span></span><span style=display:flex><span> &gt; sadd u1 a1
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>&gt; sadd u1 a2
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>&gt; sadd u1 a3
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>&gt; sadd u2 a1
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>&gt; sadd u2 a2
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 交集</span>
</span></span><span style=display:flex><span>&gt; sinter u1 u2
</span></span><span style=display:flex><span>a2
</span></span><span style=display:flex><span>a1
</span></span><span style=display:flex><span><span style=color:#75715e># 并集</span>
</span></span><span style=display:flex><span>&gt; sunion u1 u2
</span></span><span style=display:flex><span>a1
</span></span><span style=display:flex><span>a2
</span></span><span style=display:flex><span>a3
</span></span><span style=display:flex><span><span style=color:#75715e># 差集 (u1,u2)顺序不一样,结果不一样</span>
</span></span><span style=display:flex><span>&gt; sdiff u1 u2
</span></span><span style=display:flex><span>a3
</span></span></code></pre></div><p>redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热点旅游线路，应用APP推荐，大V推荐等</p><h2 id=sort_set>sort_set<a href=#sort_set class=hanchor arialabel=Anchor>&#8983;</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 添加数据</span>
</span></span><span style=display:flex><span>&gt; zadd scores <span style=color:#ae81ff>100</span>  zhangsan
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>&gt; zadd scores <span style=color:#ae81ff>90</span>  lisi
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>&gt; zadd scores <span style=color:#ae81ff>95</span>  wangwu
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取全部数据</span>
</span></span><span style=display:flex><span>&gt; zrange scores <span style=color:#ae81ff>0</span> -1
</span></span><span style=display:flex><span>lisi
</span></span><span style=display:flex><span>wangwu
</span></span><span style=display:flex><span>zhangsan
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取全部数据</span>
</span></span><span style=display:flex><span>&gt; zrange scores <span style=color:#ae81ff>0</span> -1 withscores
</span></span><span style=display:flex><span>lisi
</span></span><span style=display:flex><span><span style=color:#ae81ff>90</span>
</span></span><span style=display:flex><span>wangwu
</span></span><span style=display:flex><span><span style=color:#ae81ff>95</span>
</span></span><span style=display:flex><span>zhangsan
</span></span><span style=display:flex><span><span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 反向获取全部数据</span>
</span></span><span style=display:flex><span>&gt; zrevrange scores <span style=color:#ae81ff>0</span> -1 withscores
</span></span><span style=display:flex><span>zhangsan
</span></span><span style=display:flex><span><span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>wangwu
</span></span><span style=display:flex><span><span style=color:#ae81ff>95</span>
</span></span><span style=display:flex><span>lisi
</span></span><span style=display:flex><span><span style=color:#ae81ff>90</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 删除数据</span>
</span></span><span style=display:flex><span>&gt; zrem scores zhangsan
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>&gt; zrange scores <span style=color:#ae81ff>0</span> -1 withscores
</span></span><span style=display:flex><span>lisi
</span></span><span style=display:flex><span><span style=color:#ae81ff>90</span>
</span></span><span style=display:flex><span>wangwu
</span></span><span style=display:flex><span><span style=color:#ae81ff>95</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 按条件获取数据,可以用作分页</span>
</span></span><span style=display:flex><span>zrangebyscore key min max <span style=color:#f92672>[</span>WITHSCORES<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>LIMIT<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>zrevrangebyscore key max min <span style=color:#f92672>[</span>WITHSCORES<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 条件删除</span>
</span></span><span style=display:flex><span>zremrangebyrank key start stop
</span></span><span style=display:flex><span>zremrangebyscore key min max
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>-----------------------------------------排名-------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 添加模拟数据</span>
</span></span><span style=display:flex><span>&gt; zadd movies <span style=color:#ae81ff>143</span> aa <span style=color:#ae81ff>97</span> bb <span style=color:#ae81ff>201</span> cc
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取数据对应的索引(排名)</span>
</span></span><span style=display:flex><span>&gt; zrank movies bb
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 反向获取</span>
</span></span><span style=display:flex><span>&gt; zrevrank movies bb
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># score 值获取与修改</span>
</span></span><span style=display:flex><span>zscore key member
</span></span><span style=display:flex><span>zincrby key increment member
</span></span></code></pre></div><h1 id=redis-通用命令>Redis 通用命令<a href=#redis-通用命令 class=hanchor arialabel=Anchor>&#8983;</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 删除</span>
</span></span><span style=display:flex><span>del key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取key是否存在</span>
</span></span><span style=display:flex><span>exists key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取key的类型</span>
</span></span><span style=display:flex><span>type key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 设置指定有效期,秒</span>
</span></span><span style=display:flex><span>expire key second
</span></span><span style=display:flex><span><span style=color:#75715e># 设置指定有效期,毫秒</span>
</span></span><span style=display:flex><span>pexpire key milliseconds
</span></span><span style=display:flex><span><span style=color:#75715e># 有效期是时间戳</span>
</span></span><span style=display:flex><span>expireat key timestamp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取key的有效期</span>
</span></span><span style=display:flex><span>ttl key
</span></span><span style=display:flex><span>pttl key  毫秒
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 集群环境下,模糊查询key</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 要是查不出来数据,99999要换成一个很大的值</span>
</span></span><span style=display:flex><span>SCAN <span style=color:#ae81ff>0</span> MATCH * count <span style=color:#ae81ff>99999</span> 
</span></span></code></pre></div><h1 id=持久化>持久化<a href=#持久化 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。</p><p>Redis的一种持久化方式叫快照（snapshotting，RDB）</p><p>另一种方式是只追加文件（append-only file,AOF）</p><p>这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p><p><img src=https://image.runtimes.cc/202404051454660.png alt></p><h2 id=rdb快照>RDB(快照)<a href=#rdb快照 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>save 会生成rdb文件</p><h3 id=save指令相关配置>save指令相关配置<a href=#save指令相关配置 class=hanchor arialabel=Anchor>&#8983;</a></h3><table><thead><tr><th>配置项</th><th>描述</th><th></th></tr></thead><tbody><tr><td>dbfilename dump.rdb</td><td>指定本地数据库文件名，默认值为 dump.rdb</td><td></td></tr><tr><td>dir ./</td><td>指定本地数据库存放目录</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>注意：<strong>Redis是单线程的</strong>，所有命令都会在类似队列中排好队，不建议使用save指令，因为save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成位置，有可能会造成长时间阻塞，<strong>线上环境不建议使用</strong></p><h3 id=bgsave指令>bgsave指令<a href=#bgsave指令 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>手动启动后台保存操作，但不是立即执行</p><p><img src=https://image.runtimes.cc/202404051453704.png alt></p><p>执行成功了不会在控制台输出,可以在日志中看到</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>58142:M <span style=color:#ae81ff>07</span> Aug <span style=color:#ae81ff>2020</span> 07:23:17.355 * Starting BGSAVE <span style=color:#66d9ef>for</span> SYNC with target: disk
</span></span><span style=display:flex><span>58142:M <span style=color:#ae81ff>07</span> Aug <span style=color:#ae81ff>2020</span> 07:23:17.355 * Background saving started by pid <span style=color:#ae81ff>58183</span>
</span></span><span style=display:flex><span>58183:C <span style=color:#ae81ff>07</span> Aug <span style=color:#ae81ff>2020</span> 07:23:17.357 * DB saved on disk
</span></span><span style=display:flex><span>58183:C <span style=color:#ae81ff>07</span> Aug <span style=color:#ae81ff>2020</span> 07:23:17.357 * RDB: <span style=color:#ae81ff>0</span> MB of memory used by copy-on-write
</span></span><span style=display:flex><span>58142:M <span style=color:#ae81ff>07</span> Aug <span style=color:#ae81ff>2020</span> 07:23:17.456 * Background saving terminated with success
</span></span></code></pre></div><p>bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用</p><h3 id=save配置>save配置<a href=#save配置 class=hanchor arialabel=Anchor>&#8983;</a></h3><pre tabindex=0><code># second：监控时间范围
# changes：监控key的变化量
save second changes

save 900 1      #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 300 10     #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 60 10000    #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
</code></pre><h3 id=save配置原理>save配置原理<a href=#save配置原理 class=hanchor arialabel=Anchor>&#8983;</a></h3><p><img src=https://image.runtimes.cc/202404051453062.png alt></p><p>**注意：**save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的save配置中对second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系save配置启动后执行的是bgsave操作</p><h3 id=对比>对比<a href=#对比 class=hanchor arialabel=Anchor>&#8983;</a></h3><p><img src=https://image.runtimes.cc/202404051453536.png alt></p><h3 id=rdb启动方式>RDB启动方式<a href=#rdb启动方式 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>全量复制在主从复制中会提到</li><li>服务器运行过程中重启debug reload</li><li>关闭服务器时指定保存数据shutdown save</li></ul><h3 id=rdb-优缺点>RDB 优缺点<a href=#rdb-优缺点 class=hanchor arialabel=Anchor>&#8983;</a></h3><h3 id=rdb优点>RDB优点<a href=#rdb优点 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li><li>RDB恢复数据的速度要比AOF快很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程己气中，用于灾难恢复</li></ul><h3 id=rdb缺点>RDB缺点<a href=#rdb缺点 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具体较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现个版本服务之间数据格式无法兼容现象</li></ul><h3 id=rdb存储的弊端>RDB存储的弊端<a href=#rdb存储的弊端 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>存储数据量较大，效率较低——基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li><li>大数据量下的IO性能较低</li><li>基于fork创建子进程，内存产生额外消耗</li><li>宕机带来的数据丢失风险</li></ul><h3 id=解决思路>解决思路<a href=#解决思路 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>不写全数据，仅记录部分数据</li><li>改记录数据未记录操作过程</li><li>对所有操作均进行记录，排除丢失数据的风险</li><li>这也就是AOF的引入</li></ul><h2 id=aof>AOF<a href=#aof class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=aof写数据过程>AOF写数据过程<a href=#aof写数据过程 class=hanchor arialabel=Anchor>&#8983;</a></h3><p><img src=https://image.runtimes.cc/202404051454829.png alt></p><h3 id=aof写数据的三种策略>AOF写数据的三种策略<a href=#aof写数据的三种策略 class=hanchor arialabel=Anchor>&#8983;</a></h3><pre tabindex=0><code>appendfsync always  #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘 **(默认的)**
appendfsync no    #让操作系统决定何时进行同步
</code></pre><h3 id=aof功能开启和相关配置>AOF功能开启和相关配置<a href=#aof功能开启和相关配置 class=hanchor arialabel=Anchor>&#8983;</a></h3><pre tabindex=0><code># 是否开启APF持久化功能，默认为不开启
appendonly yes|no

# AOF写数据策略
appendfsync always|everysec|no

# AOF持久化文件名，默认文件名为appendonly.aof,建议配置为appendonly-端口号.aof
appendfilename filename

# AOF持久化文件保存路径，与RDB持久化文件保持一致即可
dir
</code></pre><h3 id=重写>重写<a href=#重写 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>随着命令的不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积，AOF文件重写是将Redis进程内的数据转换为写命令同步到新AOF文件的过程，简单说就是将同样一个数据的若干个命令执行结果转换为最终结果数据对应的指令进行记录</p><h3 id=aof重写作用>AOF重写作用<a href=#aof重写作用 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>降低磁盘占用量，提高磁盘利用路</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h3 id=aof重写规则>AOF重写规则<a href=#aof重写规则 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>进程内已超时的数据不再写入文件</li><li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令　如del key1,hdel key2,srem key3,set key 222等</li><li>对统一数据的多条命令合并为一条命令如 lpush list1 a ,lpush list1 b,lpush list1 c可以转化为lpush list1 a b c为防止数据量过大造成客户端缓冲区溢出，对list,set,hash,set等类型，每条指令最多写入64个元素</li></ul><h3 id=重写方式>重写方式<a href=#重写方式 class=hanchor arialabel=Anchor>&#8983;</a></h3><pre tabindex=0><code># 手动重写,在命令行执行,会覆盖原来的aof文件,但是文件更小
bgrewriteaof

# 自动重写
auto-aof-rewrite-min-size 		size
auto-aof-rewrite-percentage 	percentage
</code></pre><p>手动重写流程:</p><p><img src=https://image.runtimes.cc/202404051454591.png alt></p><p>自动重写的触发条件:</p><pre tabindex=0><code># 自动重写触发条件设置
auto-aof-rewrite-min-size
auto-aof-rewrite-percentage percent

# 自动重写触发对比参数（运行指令info Persistence获取具体信息）
aof_current_size
aof_base_size
</code></pre><p><img src=https://image.runtimes.cc/202404051517623.png alt></p><p><img src=https://image.runtimes.cc/202404051455402.png alt></p><p><img src=https://image.runtimes.cc/202404051456010.png alt></p><h2 id=aof和rdb的区别>AOF和RDB的区别<a href=#aof和rdb的区别 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><img src=https://image.runtimes.cc/202404051456409.png alt></p><h3 id=rdb和aof的选择之感>RDB和AOF的选择之感<a href=#rdb和aof的选择之感 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案AOF持久化策略使用erverysecond，每秒钟fsync一次。该策略redis任然可以保持很好的处理性能，当出现问题时，最多丢失0-1秒中的数据。注意：由于AOF文件存储体积较大，且恢复数据较慢</li><li>数据呈现阶段有效性，建议使用RDB持久化方案数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人工手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案注意：利用RDB实现紧凑的数据持久化会使Redis降得很低</li><li>综合对比</li></ul><ol><li>RDB与AOF得选择实际上是在做一种权衡，每种都有利弊</li><li>如不能承受数分钟以内得数据丢失，对业务数据非常敏感，选用AOF</li><li>如能承受数分钟以内数据丢失，且追求大数据集得恢复速度，选用RDB灾难恢复选用RDB</li><li>双保险策略，同时开启RDB和AOF，重启后，Redis优先使用AOF来恢复数据，降低丢失数据的量</li></ol><h2 id=redis-40-对于持久化机制的优化><strong>Redis 4.0 对于持久化机制的优化</strong><a href=#redis-40-对于持久化机制的优化 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><h1 id=事务>事务<a href=#事务 class=hanchor arialabel=Anchor>&#8983;</a></h1><pre tabindex=0><code># 开启事务,设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中
multi

# 执行提交事务,加入事务的命令暂时到任务队列中，并没有立即执行，只有执行exec命令才开始执行
exec

# 取消事务,终止当前事务定义，发生在multi之后，exec之前
discard
</code></pre><h2 id=事务的工作流程>事务的工作流程<a href=#事务的工作流程 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><img src=https://image.runtimes.cc/202404051456083.png alt></p><h2 id=事务的注意事项>事务的注意事项<a href=#事务的注意事项 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>语法错误指命令书写格式有误</li><li>处理结果如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会被执行。包括那些语法正确的命令</li></ul><hr><ul><li>运行错误指命令格式正确，但是无法正常的执行。例如对list进行incr操作</li><li>处理结果能够正确运行的命令会执行，运行错误的命令不会执行注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</li></ul><h3 id=手动进行事务回滚基本没法用>手动进行事务回滚(基本没法用)<a href=#手动进行事务回滚基本没法用 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>记录操作过程中被影响的数据之前的状态单数据：string多数据：hash,list,set,zset</li><li>设置指令恢复所有的被修改的项单数据：直接set（注意周边属性，例如时效）多数据：修改对应值或整体克隆复制</li></ul><h1 id=锁>锁<a href=#锁 class=hanchor arialabel=Anchor>&#8983;</a></h1><pre tabindex=0><code># 对key添加监视锁，在执行exec前如果key发生了变化，终止事务执行
watch key1 [key2…]

# 取消对所有key的监视
unwatch
</code></pre><h2 id=分布式锁>分布式锁<a href=#分布式锁 class=hanchor arialabel=Anchor>&#8983;</a></h2><pre tabindex=0><code># 加锁
setnx lock-key value

# 设置超时时间
expire lock-key second

# 删除锁
dek lock-key
</code></pre><ul><li>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</li><li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</li><li>对于返回设置失败的，不具有控制权，排队或等待操作完毕通过<strong>del</strong>操作释放锁</li></ul><h1 id=删除策略>删除策略<a href=#删除策略 class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=过期数据删除策略>过期数据删除策略<a href=#过期数据删除策略 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态</li><li>XX : 具有时效性的数据</li><li>1 : 永久有效的数据</li><li>2 : 已经国企的数据 或 被删除的数据 或 未定义的数据</li></ul><h2 id=时效性数据的存储结构>时效性数据的存储结构<a href=#时效性数据的存储结构 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><img src=https://image.runtimes.cc/202404051457852.png alt></p><h3 id=定时删除>定时删除<a href=#定时删除 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>创建一个定时器，当key设置过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</li><li><strong>优点</strong>：节约内存，到时就删除，快速释放掉不必要的内存占用</li><li><strong>缺点</strong>：CPU压力很大，无论CPU此时负载多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li><strong>总结</strong>：用处理器性能换取存储空间</li></ul><h3 id=惰性删除>惰性删除<a href=#惰性删除 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>数据到达过期时间，不做处理。等下次访问该数据</li></ul><ol><li>如果未过期，返回数据</li><li>发现已经过期，删除，返回不存在</li></ol><ul><li>优点：节约CPU性能，发现必须删除的时候才删除</li><li>缺点：内存压力很大，出现长期占用内存的数据</li><li>总结：用存储空间换取处理器性能</li></ul><h3 id=定期删除>定期删除<a href=#定期删除 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</li><li>每秒钟执行server.hz次serverCron()</li></ul><p><img src=https://image.runtimes.cc/202404051457886.png alt></p><ul><li>周期性轮询redis库中时效性数据，采用随机抽取的策略，利用过期数据占比的方式删除频度</li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li><li>总结：周期性抽查存储空间</li></ul><p><img src=https://image.runtimes.cc/202404051516388.png alt></p><h1 id=逐出算法>逐出算法<a href=#逐出算法 class=hanchor arialabel=Anchor>&#8983;</a></h1><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</li><li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息</li></ul><p><img src=https://image.runtimes.cc/202404051457056.png alt></p><p>相关配置</p><pre tabindex=0><code># 最大可使用内存
maxmemory

# 每次选取代删除数据的个数
maxmemory-samples

# 删除策略
maxmemory-policy
</code></pre><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</td></tr><tr><td>volatile-lfu</td><td>从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</td></tr><tr><td>allkeys-lru</td><td>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key （这个是最常用的）</td></tr><tr><td>allkeys-random</td><td>从数据集（server.db[i].dict）中任意选择数据淘汰</td></tr><tr><td>allkeys-lfu</td><td>当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</td></tr><tr><td>no-eviction</td><td>禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</td></tr></tbody></table><p><img src=https://image.runtimes.cc/202404051457458.png alt></p><p>数据逐出策略配置依据</p><ul><li>使用INFO命令输出监控信息，查询缓存int和miss的次数，根据业务需求调优Redis配置</li></ul><h1 id=配置文件>配置文件<a href=#配置文件 class=hanchor arialabel=Anchor>&#8983;</a></h1><pre tabindex=0><code># 设置服务器以守护进程的方式运行
deamonize yes|no

# 绑定主机地址
bind 127.0.0.1

# 设置服务器端口号
port 6379

# 设置数据库数量
databases 16

----------------------------------日志配置--------------------------------------
# 设置服务器以指定日志记录级别
loglevel debug|verbose|notice|warning

# 日志记录文件名
logfile 端口号.log

# 持久化文件存放目录
dir ./

----------------------------------日志配置--------------------------------------

# 设置同一时间最大客户链接数，默认无限制。当客户端连接到达上线，Redis会关闭新的链接
maxclients 0

# 客户端限制等待最大时常，达到最大之后关闭连接。如需关闭该功能，设置为0
timeout 300
</code></pre><h1 id=redis-cluster结构设计>Redis-Cluster结构设计<a href=#redis-cluster结构设计 class=hanchor arialabel=Anchor>&#8983;</a></h1><h1 id=数据存储设计>数据存储设计<a href=#数据存储设计 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Key -> CRC16(Key) 相当于HashCode值&mdash;>%16384</p><ul><li>将所有的存储空间计划切割成16384份，每台主机保存一部分,每份代表的使一个存储空间，不是一个key的保存空间</li><li>将key按照计算出的结果放到对应的存储空间</li></ul><p><img src=https://image.runtimes.cc/202404051457725.png alt></p><p>当有新的机器加入集群的时候,就会每台机器转移一些数据空间</p><p><img src=https://image.runtimes.cc/202404051457378.png alt></p><h1 id=集群内部通讯设计>集群内部通讯设计<a href=#集群内部通讯设计 class=hanchor arialabel=Anchor>&#8983;</a></h1><p><img src=https://image.runtimes.cc/202404051458468.png alt></p><h1 id=集群常用命令>集群常用命令<a href=#集群常用命令 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>参考:<a href=https://www.cnblogs.com/kevingrace/p/7910692.html>https://www.cnblogs.com/kevingrace/p/7910692.html</a></p><p>以下命令是Redis Cluster集群所独有的，执行下面命令需要先登录redis</p><pre tabindex=0><code># （客户端命令：redis-cli -c -p port -h ip）
[root@manage redis]# redis-cli -c -p 6382 -h 192.168.10.12
192.168.10.12:6382&gt;
</code></pre><ul><li>集群<code>cluster info</code> ：打印集群的信息<code>cluster nodes</code> ：列出集群当前已知的所有节点（ node），以及这些节点的相关信息。</li><li>节点<code>cluster meet &lt;ip> &lt;port></code> ：将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。<code>cluster forget &lt;node_id></code>：从集群中移除 node_id 指定的节点。<code>cluster replicate &lt;master_node_id></code> ：将当前从节点设置为 node_id 指定的master节点的slave节点。只能针对slave节点操作。<code>cluster saveconfig</code> ：将节点的配置文件保存到硬盘里面。</li><li>slot<code>cluster addslots &lt;slot> [slot ...]</code> ：将一个或多个槽（ slot）指派（ assign）给当前节点。<code>cluster delslots &lt;slot> [slot ...]</code> ：移除一个或多个槽对当前节点的指派。<code>cluster flushslots</code> ：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。<code>cluster setslot &lt;slot> node &lt;node_id></code>：将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给</li><li>另一个节点，那么先让另一个节点删除该槽>，然后再进行指派<code>cluster setslot &lt;slot> migrating &lt;node_id></code>：将本节点的槽 slot 迁移到 node_id 指定的节点中。<code>cluster setslot &lt;slot> importing &lt;node_id></code> ：从 node_id 指定的节点中导入槽 slot 到本节点。<code>cluster setslot &lt;slot> stable</code>：取消对槽 slot 的导入（ import）或者迁移（ migrate）。</li><li>键<code>cluster keyslot &lt;key></code>：计算键 key 应该被放置在哪个槽上。<code>cluster countkeysinslot &lt;slot></code>：返回槽 slot 目前包含的键值对数量。<code>cluster getkeysinslot &lt;slot> &lt;count></code>：返回 count 个 slot 槽中的键 。</li></ul><h1 id=解决方案>解决方案<a href=#解决方案 class=hanchor arialabel=Anchor>&#8983;</a></h1><h1 id=缓存预热>缓存预热<a href=#缓存预热 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>在高请求之前，做好一系列措施，保证大量用户数量点击造成灾难。</p><ol><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ol><h3 id=缓存预热解决方案>缓存预热解决方案<a href=#缓存预热解决方案 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>前置准备工作：</p><ol><li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li><li>利用LRU数据删除策略，构建数据留存队列例如：storm与kafka配合</li></ol><p>准备工作：</p><ol><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li></ol><p>实施：</p><ol><li>使用脚本程序固定出大数据预热过程</li><li>如果条件允许，使用CDN（内容分发网络），效果会更好</li></ol><p>缓存预热总结：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据!</p><h1 id=缓存雪崩>缓存雪崩<a href=#缓存雪崩 class=hanchor arialabel=Anchor>&#8983;</a></h1><ol><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时请求</li><li>大量408，500错误页面出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据之后再次被瞬间流量放倒</li></ol><h3 id=问题排查>问题排查<a href=#问题排查 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉</p><ol><li>在一个较短的时间内，缓存中较多的key集中过期</li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接受到大量的请求无法即时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后任然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法即时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想</li></ol><h3 id=问题分析>问题分析<a href=#问题分析 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>短时间范围内</li><li>大量key集中过期</li></ul><h3 id=解决方案道>解决方案（道）<a href=#解决方案道 class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>更多的页面静态化处理</li><li>构建多级缓存架构Nginx缓存+redis缓存+ehcache缓存</li><li>检测Mysql严重耗时业务进行优化对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li><li>灾难预警机制监控redis服务器性能指标1、CPU占用、CPU使用率2、内存容量3、查询平均响应时间4、线程数</li><li>限流、降级短时间范围内习生一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐渐放开访问</li></ol><h3 id=解决方案术>解决方案（术）<a href=#解决方案术 class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>LRU与LFU切换</li><li>数据有效期策略调整根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟过期时间使用固定形式+随机值的形式，稀释集中到期的key的数量</li><li>超热数据使用永久key</li><li>定期维护（自动+人工）对即将过期数据做访问量分析，确认是否演示，配合访问量统计，做热点数据的延时</li><li>加锁 慎用！！！！！！！</li></ol><p>总结缓存雪崩式瞬间过期数量太大，导致对数据库服务器造成压力。如果能有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%）。配合其他策略一起使用，并监控服务器的运行数据，根据运行巨鹿做快速调整</p><p><img src=https://image.runtimes.cc/202404051458329.png alt></p><h1 id=缓存击穿>缓存击穿<a href=#缓存击穿 class=hanchor arialabel=Anchor>&#8983;</a></h1><h3 id=数据库服务器崩溃2>数据库服务器崩溃（2）<a href=#数据库服务器崩溃2 class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>系统平稳运行过程中</li><li>数据库连接量瞬间激增</li><li>Redis服务器无大量key过期</li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li>数据库崩溃</li></ol><h3 id=问题排查-1>问题排查<a href=#问题排查-1 class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>Redis中某个key过期，该key访问量巨大</li><li>多个数据请求从服务器直接压到Redis后，均为命中</li><li>Redis在短时间内发起了大量对数据库中同一个数据的访问</li></ol><p><strong>问题分析</strong></p><ul><li>单个key高热数据</li><li>key过期</li></ul><h3 id=解决方案术-1>解决方案（术）<a href=#解决方案术-1 class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>预先设定以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时常注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低趋势</li><li>现场调整监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li><li>后台刷新数据启动定时任务，高峰期来临之前，刷新数据有效期，保存不丢失</li><li>二级缓存设置不同的失效时间，保障不会被同时淘汰就行</li><li>加锁分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！！！！！！！！</li></ol><p>总结：缓存击穿就是单个高热数据过期的瞬间，数据访问较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可</p><h1 id=缓存穿透>缓存穿透<a href=#缓存穿透 class=hanchor arialabel=Anchor>&#8983;</a></h1><h3 id=数据库服务器崩溃3>数据库服务器崩溃（3）<a href=#数据库服务器崩溃3 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><ol><li>系统平稳运行过程中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳，内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li>数据库崩溃</li></ol><h3 id=问题排查-2>问题排查<a href=#问题排查-2 class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>redis中大面积出现未命中</li><li>出现非正常URL访问</li></ol><p><strong>问题分析</strong></p><ul><li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li><li>Redis获取到null数据未进行持久化，直接返回</li><li>下次此类数据到达重复上述过程</li><li>出现黑客攻击服务器</li></ul><h3 id=解决方法术>解决方法（术）<a href=#解决方法术 class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>缓存null对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高五分钟</li><li>白名单策略提前预热各种分类数据id对应的bitmaps,id作为bitmaps的offset,相当于设置了数据白名单。当加载正常数据后放型，加载异常数据时直接拦截（效率偏低）使用布隆过滤器（有关布隆过滤器的命中问题对当前状态可以忽略）</li><li>实时监控试试监控redis命中率（业务正常范围时，通常回有一个波动值）与null数据的占比非活动时间波动：通常检测3-5倍，超过5倍纳入重点排查对象活动时间波动：通常检测10-50倍，超过50倍纳入重点排查对象根据背书不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li><li>key加密问题出现后，临时启动防灾业务key,对key进行业务层传输加密服务，设定校验程序，过来的key校验例如每天随机分配60个加密串，挑选2-3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</li></ol><p><strong>总结</strong>缓存穿透是访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并即时报警。应对策略应该在临时预案防范方面多做文章无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除</p><h1 id=redis-java>Redis-Java<a href=#redis-java class=hanchor arialabel=Anchor>&#8983;</a></h1><h1 id=单机jedis>单机Jedis<a href=#单机jedis class=hanchor arialabel=Anchor>&#8983;</a></h1><pre tabindex=0><code>/**
 * 192.168.0.5 单机
 */
public class SingletonDemo {

    private Jedis jedis;

    @Before
    public void before() {
        //指定Redis服务Host和port
        jedis = new Jedis(&#34;192.168.0.5&#34;, 6379);
    }

    @After
    public void after() {
        //使用完关闭连接
        jedis.close();
    }

    /**
     * 设值
     */
    @Test
    public void set() {
        //访问Redis服务
        jedis.set(&#34;k1&#34;, &#34;v1&#34;);
        System.out.println(jedis.get(&#34;k1&#34;));
    }

    /**
     * 设值,并且设置超时时间
     */
    @Test
    public void setTime() {
        String key = &#34;setTimeKey&#34;;
        jedis.setex(key, 20000, &#34;setTimeValue&#34;);
        System.out.println(jedis.get(key));
        System.out.println(jedis.ttl(key));
    }

    /**
     * 分布式锁原理,
     * key不存在的时候才插入
     */
    @Test
    public void setNX() {
        String key = &#34;setNXKey&#34;;
        // 1.先插入一个值
        jedis.set(key, &#34;setNXValue&#34;);

        // 2.NX是不存在时才set， XX是存在时才set， EX是秒，PX是毫秒
        String set = jedis.set(key, &#34;setNXValue---NX&#34;, &#34;NX&#34;, &#34;EX&#34;, 20000L);
        System.out.println(set);
        System.out.println(jedis.get(key));
        System.out.println(jedis.ttl(key));

        System.out.println(&#34;======================================================&#34;);

        // 3.设置个没有的key
        String key2 = &#34;setNXKey2&#34;;
        String set2 = jedis.set(key2, &#34;setNXValue2---NX&#34;, &#34;NX&#34;, &#34;EX&#34;, 20000L);
        System.out.println(set2);
        System.out.println(jedis.get(key2));
        System.out.println(jedis.ttl(key2));
    }

    /**
     * key存在时才插入
     */
    @Test
    public void setXX() {
        String key = &#34;setXXKey&#34;;
        // 1.先插入一个值
        jedis.set(key, &#34;setXXValue&#34;);

        // 2.NN
        String set = jedis.set(key, &#34;setXXValue---XX&#34;, &#34;XX&#34;, &#34;EX&#34;, 20000L);
        System.out.println(set);
        System.out.println(jedis.get(key));
        System.out.println(jedis.ttl(key));

        System.out.println(&#34;======================================================&#34;);

        // 3.设置个没有的key
        String key2 = &#34;setXXKey2&#34;;
        String set2 = jedis.set(key2, &#34;setXXValue2---NX&#34;, &#34;XX&#34;, &#34;EX&#34;, 20000L);
        System.out.println(set2);
        System.out.println(jedis.get(key2));
        System.out.println(jedis.ttl(key2));
    }

    @Test
    public void expire() {
    }

    /**
     * redis监控信息
     */
    @Test
    public void info() {
        String info = jedis.info();
        Stream.of(info.split(&#34;\r\n&#34;)).forEach(row -&gt; {

                    String[] split = row.split(&#34;:&#34;);
                    if (split.length == 2) {

                        System.out.printf(&#34;key:%s ====  value:%s \r\n&#34;,split[0],split[1]);
                    }

                }
        );
    }

    /**
     * jedispool
     */
    @Test
    public void jedisPool() throws InterruptedException {

        StopWatch watch = new StopWatch();
        watch.start();

        for (int i = 0; i &lt; 100000; i++) {
            jedis.set(i + &#34;&#34;, i + &#34;&#34;);
            jedis.close();
        }
        watch.stop();
        System.out.println(&#34;5-&#34;+watch.getTime());
    }

    @Test
    public void jedisPool2() {

        // 替换成你的reids地址和端口
        String redisIp = &#34;192.168.0.5&#34;;
        int reidsPort = 6379;
        JedisPool jedisPool = new JedisPool(new JedisPoolConfig(), redisIp, reidsPort);
        Jedis resource = jedisPool.getResource();
        StopWatch watch = new StopWatch();
        watch.start();

        for (int i = 0; i &lt; 100000; i++) {
            resource.set(i + &#34;&#34;, i + &#34;&#34;);
        }
        watch.stop();
        System.out.println(&#34;5-&#34;+watch.getTime());

    }
}
</code></pre><h1 id=单机jedis连接集群节点>单机Jedis连接集群节点<a href=#单机jedis连接集群节点 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>会报错</p><pre tabindex=0><code>redis.clients.jedis.exceptions.JedisMovedDataException: MOVED 12706 192.168.0.8:6379
	at redis.clients.jedis.Protocol.processError(Protocol.java:115)
	at redis.clients.jedis.Protocol.process(Protocol.java:161)
	at redis.clients.jedis.Protocol.read(Protocol.java:215)
	at redis.clients.jedis.Connection.readProtocolWithCheckingBroken(Connection.java:340)
	at redis.clients.jedis.Connection.getStatusCodeReply(Connection.java:239)
	at redis.clients.jedis.Jedis.set(Jedis.java:121)
	at reids.ClusterDemo.set(ClusterDemo.java:68)
</code></pre><h1 id=集群jedis>集群Jedis<a href=#集群jedis class=hanchor arialabel=Anchor>&#8983;</a></h1><pre tabindex=0><code>/**
 * anthony@base:/var/log/redis$ redis-cli --cluster check 192.168.0.6:6379
 * 192.168.0.6:6379 (99af86e5...) -&gt; 0 keys | 5461 slots | 1 slaves.
 * 192.168.0.8:6379 (982f74c7...) -&gt; 3 keys | 5461 slots | 1 slaves.
 * 192.168.0.7:6379 (1069a632...) -&gt; 0 keys | 5462 slots | 1 slaves.
 * [OK] 3 keys in 3 masters.
 * 0.00 keys per slot on average.
 * &gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.6:6379)
 * M: 99af86e59c7f5a4ddf212b29e9e1b12fa5e7a866 192.168.0.6:6379
 *    slots:[0-5460] (5461 slots) master
 *    1 additional replica(s)
 * S: 102517bddae6af2434519e8f348cf062b0152fa7 192.168.0.9:6379
 *    slots: (0 slots) slave
 *    replicates 982f74c79ed5c5811b7011507c56f81374c70a0b
 * S: 392c5e4dcd5608c74a76902668ed58fb6ab50aaf 192.168.0.11:6379
 *    slots: (0 slots) slave
 *    replicates 1069a6320a0489f63e807c970c27f86f13f417cf
 * S: 4d12dd0de1af9d90bfac7dd141c36c348071d59f 192.168.0.10:6379
 *    slots: (0 slots) slave
 *    replicates 99af86e59c7f5a4ddf212b29e9e1b12fa5e7a866
 * M: 982f74c79ed5c5811b7011507c56f81374c70a0b 192.168.0.8:6379
 *    slots:[10923-16383] (5461 slots) master
 *    1 additional replica(s)
 * M: 1069a6320a0489f63e807c970c27f86f13f417cf 192.168.0.7:6379
 *    slots:[5461-10922] (5462 slots) master
 *    1 additional replica(s)
 * [OK] All nodes agree about slots configuration.
 * &gt;&gt;&gt; Check for open slots...
 * &gt;&gt;&gt; Check slots coverage...
 * [OK] All 16384 slots covered.
 */
public class ClusterDemo {

    private JedisCluster jedis;

    @Before
    public void before() {
        Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();
        nodes.add(new HostAndPort(&#34;192.168.0.6&#34;, 6379));
        nodes.add(new HostAndPort(&#34;192.168.0.7&#34;, 6379));
        nodes.add(new HostAndPort(&#34;192.168.0.8&#34;, 6379));
        nodes.add(new HostAndPort(&#34;192.168.0.9&#34;, 6379));
        nodes.add(new HostAndPort(&#34;192.168.0.10&#34;, 6379));
        nodes.add(new HostAndPort(&#34;192.168.0.11&#34;, 6379));

        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
        jedis = new JedisCluster(nodes,poolConfig);
    }

    @After
    public void after() throws IOException {
        //使用完关闭连接
        jedis.close();
    }

    /**
     * 设值
     */
    @Test
    public void set() {
        //访问Redis服务
        jedis.set(&#34;k1&#34;, &#34;v1&#34;);
        System.out.println(jedis.get(&#34;k1&#34;));
    }

    /**
     * redis集群的节点信息
     * map.key = IP:PORT
     */
    @Test
    public void info() {
        Map&lt;String, JedisPool&gt; clusterNodes = jedis.getClusterNodes();
        clusterNodes.keySet().forEach(key-&gt;{
            System.out.printf(&#34;%s==%s\r\n&#34;,key,clusterNodes.get(key).getResource().info());
        });
    }
}
</code></pre><p>RedisTemplate</p><pre tabindex=0><code># 插入
myVO.setCode(typeCode);
redisTemplate.opsForList().rightPush(key, JSONUtil.toJsonStr(myVO));

# 取出
List&lt;String&gt; range = redisTemplate.opsForList().range(key, 0, 100);

# 删除取出的
# trim 是保留的意思
if(range.size()  &gt;0){
    redisTemplate.opsForList().trim(key, range.size() + 1, -1);
}
</code></pre></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://connorzhangyu.com/posts/python/><span class=button__icon>←</span>
<span class=button__text>Python</span>
</a></span><span class="button next"><a href=https://connorzhangyu.com/posts/spring-security/><span class=button__text>Spring Security</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>