<!doctype html><html lang=zh><head><title>collection :: Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="容器 java 容器都有哪些？ 常用容器的图录：
Collection 和 Collections 有什么区别？ java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。
Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。
List、Set、Map 之间的区别是什么？ HashMap 和 Hashtable 有什么区别？ hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。
hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。
hashMap允许空键值，而hashTable不允许。
如何决定使用 HashMap 还是 TreeMap？ 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。
然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。
基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。
说一下 HashMap 的实现原理？ HashMap概述：
HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
HashMap的数据结构：
在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根据hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。
需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)
说一下 HashSet 的实现原理？ HashSet底层由HashMap实现
HashSet的值存放于HashMap的key上
HashMap的value统一为PRESENT
ArrayList 和 LinkedList 的区别是什么？ 最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。
如何实现数组和 List 之间的转换？ List转换成为数组：调用ArrayList的toArray方法。
数组转换成为List：调用Arrays的asList方法。
ArrayList 和 Vector 的区别是什么？ Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
ArrayList比Vector快，它因为有同步，不会过载。
ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=../../posts/collection/><link rel=stylesheet href=../../styles.css><link rel="shortcut icon" href=../../img/theme-colors/orange.png><link rel=apple-touch-icon href=../../img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Connor"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="og:title" content="collection"><meta property="og:description" content="容器 java 容器都有哪些？ 常用容器的图录：
Collection 和 Collections 有什么区别？ java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。
Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。
List、Set、Map 之间的区别是什么？ HashMap 和 Hashtable 有什么区别？ hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。
hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。
hashMap允许空键值，而hashTable不允许。
如何决定使用 HashMap 还是 TreeMap？ 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。
然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。
基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。
说一下 HashMap 的实现原理？ HashMap概述：
HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
HashMap的数据结构：
在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根据hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。
需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)
说一下 HashSet 的实现原理？ HashSet底层由HashMap实现
HashSet的值存放于HashMap的key上
HashMap的value统一为PRESENT
ArrayList 和 LinkedList 的区别是什么？ 最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。
如何实现数组和 List 之间的转换？ List转换成为数组：调用ArrayList的toArray方法。
数组转换成为List：调用Arrays的asList方法。
ArrayList 和 Vector 的区别是什么？ Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
ArrayList比Vector快，它因为有同步，不会过载。
ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。
"><meta property="og:url" content="/posts/collection/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="/"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-01-04 04:08:55 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=../../><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=../../posts/collection/>collection</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><div><h1 id=容器>容器<a href=#容器 class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=java-容器都有哪些>java 容器都有哪些？<a href=#java-容器都有哪些 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>常用容器的图录：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/50db8810cd8a2e8038518950609a4e70a630e0f634e152308a104b665732101c6f98885b0382fadfdf7bd7827237a7b9?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=495869333&amp;fname=%E5%AE%B9%E5%99%A8.png&amp;size=750" alt=容器></p><h2 id=collection-和-collections-有什么区别>Collection 和 Collections 有什么区别？<a href=#collection-和-collections-有什么区别 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。<br>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p><h2 id=listsetmap-之间的区别是什么>List、Set、Map 之间的区别是什么？<a href=#listsetmap-之间的区别是什么 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/53645c0581237e3d85c558727d8943685fb28c22aaac3b1dc797a30cb39da13f988fc08da23117883268da5d5a0470b7?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=495869333&amp;fname=List-Set-Map%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.png&amp;size=750" alt=List-Set-Map之间的区别></p><h2 id=hashmap-和-hashtable-有什么区别>HashMap 和 Hashtable 有什么区别？<a href=#hashmap-和-hashtable-有什么区别 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。<br>hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。<br>hashMap允许空键值，而hashTable不允许。</p><h2 id=如何决定使用-hashmap-还是-treemap>如何决定使用 HashMap 还是 TreeMap？<a href=#如何决定使用-hashmap-还是-treemap class=hanchor arialabel=Anchor>&#8983;</a></h2><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。<br>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。<br>基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h2 id=说一下-hashmap-的实现原理>说一下 HashMap 的实现原理？<a href=#说一下-hashmap-的实现原理 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>HashMap概述：<br>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap的数据结构：<br>在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根据hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。<br>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p><h2 id=说一下-hashset-的实现原理>说一下 HashSet 的实现原理？<a href=#说一下-hashset-的实现原理 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>HashSet底层由HashMap实现<br>HashSet的值存放于HashMap的key上<br>HashMap的value统一为PRESENT</p><h2 id=arraylist-和-linkedlist-的区别是什么>ArrayList 和 LinkedList 的区别是什么？<a href=#arraylist-和-linkedlist-的区别是什么 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p><h2 id=如何实现数组和-list-之间的转换>如何实现数组和 List 之间的转换？<a href=#如何实现数组和-list-之间的转换 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>List转换成为数组：调用ArrayList的toArray方法。<br>数组转换成为List：调用Arrays的asList方法。</p><h2 id=arraylist-和-vector-的区别是什么>ArrayList 和 Vector 的区别是什么？<a href=#arraylist-和-vector-的区别是什么 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。<br>ArrayList比Vector快，它因为有同步，不会过载。<br>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p><h2 id=array-和-arraylist-有何区别>Array 和 ArrayList 有何区别？<a href=#array-和-arraylist-有何区别 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。<br>Array是指定大小的，而ArrayList大小是固定的。<br>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p><h2 id=在-queue-中-poll和-remove有什么区别>在 Queue 中 poll()和 remove()有什么区别？<a href=#在-queue-中-poll和-remove有什么区别 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p><h2 id=哪些集合类是线程安全的>哪些集合类是线程安全的？<a href=#哪些集合类是线程安全的 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。<br>statck：堆栈类，先进后出。<br>hashtable：就比hashmap多了个线程安全。<br>enumeration：枚举，相当于迭代器。</p><h2 id=迭代器-iterator-是什么>迭代器 Iterator 是什么？<a href=#迭代器-iterator-是什么 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p><h2 id=iterator-怎么使用有什么特点>Iterator 怎么使用？有什么特点？<a href=#iterator-怎么使用有什么特点 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Java中的Iterator功能比较简单，并且只能单向移动：</p><ol><li>使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</li><li>使用next()获得序列中的下一个元素。</li><li>使用hasNext()检查序列中是否还有元素。</li><li>使用remove()将迭代器新返回的元素删除。</li></ol><p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p><h2 id=iterator-和-listiterator-有什么区别>Iterator 和 ListIterator 有什么区别？<a href=#iterator-和-listiterator-有什么区别 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p><h2 id=目录>目录<a href=#目录 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><a href=../../java/javaBase.md>Java基础</a></li><li><a href=../../java/collection.md>容器</a></li><li><a href=../../java/thread.md>线程</a></li><li><a href=../../java/reflection.md>反射</a></li><li><a href=../../java/cloneable.md>对象克隆</a></li><li><a href=../../java/javaWeb.md>JavaWeb</a></li><li><a href=../../java/exception.md>异常</a></li><li><a href=../../java/netWork.md>网络服务</a></li><li><a href=../../java/designpattern.md>设计模式</a></li><li><a href=../../java/spring.md>Spring</a></li><li><a href=../../java/springMVC.md>Spring MVC</a></li><li><a href=../../java/springBoot.md>Spring Boot</a></li><li><a href=../../java/springCloud.md>Spring Cloud</a></li><li><a href=../../java/hibernate.md>Hibernate</a></li><li><a href=../../java/mybatis.md>Mybatis</a></li><li><a href=../../java/mq.md>队列</a></li><li><a href=../../java/zookeeper.md>Zookeeper</a></li><li><a href=../../java/mySql.md>MySql</a></li><li><a href=../../java/redis.md>Redis</a></li><li><a href=../../java/jvm.md>Jvm</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=../../posts/cloneable/><span class=button__icon>←</span>
<span class=button__text>cloneable</span>
</a></span><span class="button next"><a href=../../posts/designpattern/><span class=button__text>designpattern</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=../../bundle.min.js></script></div></body></html>