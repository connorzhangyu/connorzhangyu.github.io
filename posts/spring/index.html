<!doctype html><html lang=zh><head><title>Spring :: Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="SpringMVC 总结：
首先请求进入DispatcherServlet 由DispatcherServlet 从HandlerMappings中提取对应的Handler。 2.此时只是获取到了对应的Handle，然后得去寻找对应的适配器，即：HandlerAdapter。 拿到对应HandlerAdapter时，这时候开始调用对应的Handler处理业务逻辑了。 （这时候实际上已经执行完了我们的Controller） 执行完成之后返回一个ModeAndView 这时候交给我们的ViewResolver通过视图名称查找出对应的视图然后返回。 最后 渲染视图 返回渲染后的视图 &ndash;>响应请求。 初始化过程 version 5.3.8
// org.springframework.web.servlet.HttpServletBean#init @Override public final void init() throws ServletException { // 子类实现,初始化web环境 // Let subclasses do whatever initialization they like. initServletBean(); } // org.springframework.web.servlet.FrameworkServlet#initServletBean @Override protected final void initServletBean() throws ServletException { // 初始化spring上下文 this.webApplicationContext = initWebApplicationContext(); // 子类实现 initFrameworkServlet(); } // org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext protected WebApplicationContext initWebApplicationContext() { WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { // A context instance was injected at construction time -> use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { // The context has not yet been refreshed -> provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) { // The context instance was injected without an explicit parent -> set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); } //配置和刷新spring容器（重要） //这个无非就是初始化spring ioc的环境，创建bean和实例化bean等操作 //这个方法最终也是调用refresh()方法，已在spring源码解析中解析过了 configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { // No context instance was injected at construction time -> see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); } if (wac == null) { // No context instance is defined for this servlet -> create a local one wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -> trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) { // 初始化DispatcherServlet的配置initStrategies() onRefresh(wac); } } if (this.publishContext) { // Publish the context as a servlet context attribute. String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); } return wac; } // org.springframework.web.servlet.DispatcherServlet#onRefresh	protected void onRefresh(ApplicationContext context) { // //初始化springmvc的配置 initStrategies(context); } 总体流程:
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=../../posts/spring/><link rel=stylesheet href=../../styles.css><link rel="shortcut icon" href=../../img/theme-colors/orange.png><link rel=apple-touch-icon href=../../img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Anthony"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="og:title" content="Spring"><meta property="og:description" content="SpringMVC 总结：
首先请求进入DispatcherServlet 由DispatcherServlet 从HandlerMappings中提取对应的Handler。 2.此时只是获取到了对应的Handle，然后得去寻找对应的适配器，即：HandlerAdapter。 拿到对应HandlerAdapter时，这时候开始调用对应的Handler处理业务逻辑了。 （这时候实际上已经执行完了我们的Controller） 执行完成之后返回一个ModeAndView 这时候交给我们的ViewResolver通过视图名称查找出对应的视图然后返回。 最后 渲染视图 返回渲染后的视图 &ndash;>响应请求。 初始化过程 version 5.3.8
// org.springframework.web.servlet.HttpServletBean#init @Override public final void init() throws ServletException { // 子类实现,初始化web环境 // Let subclasses do whatever initialization they like. initServletBean(); } // org.springframework.web.servlet.FrameworkServlet#initServletBean @Override protected final void initServletBean() throws ServletException { // 初始化spring上下文 this.webApplicationContext = initWebApplicationContext(); // 子类实现 initFrameworkServlet(); } // org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext protected WebApplicationContext initWebApplicationContext() { WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { // A context instance was injected at construction time -> use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { // The context has not yet been refreshed -> provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) { // The context instance was injected without an explicit parent -> set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); } //配置和刷新spring容器（重要） //这个无非就是初始化spring ioc的环境，创建bean和实例化bean等操作 //这个方法最终也是调用refresh()方法，已在spring源码解析中解析过了 configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { // No context instance was injected at construction time -> see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); } if (wac == null) { // No context instance is defined for this servlet -> create a local one wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -> trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) { // 初始化DispatcherServlet的配置initStrategies() onRefresh(wac); } } if (this.publishContext) { // Publish the context as a servlet context attribute. String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); } return wac; } // org.springframework.web.servlet.DispatcherServlet#onRefresh	protected void onRefresh(ApplicationContext context) { // //初始化springmvc的配置 initStrategies(context); } 总体流程:
"><meta property="og:url" content="/posts/spring/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="https://image.runtimes.cc/202404051534866.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="Java"><meta property="article:section" content="Spring"><meta property="article:published_time" content="2023-08-25 14:58:26 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=../../><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=../../posts/spring/>Spring</a></h1><div class=post-meta><time class=post-date>2023-08-25</time><span class=post-author>Anthony</span></div><span class=post-tags>#<a href=../../tags/java/>Java</a>&nbsp;
</span><img src=https://image.runtimes.cc/202404051534866.png class=post-cover alt=" " title="Cover Image"><div class=post-content><div><h1 id=springmvc>SpringMVC<a href=#springmvc class=hanchor arialabel=Anchor>&#8983;</a></h1><p><img src=https://image.runtimes.cc/202404051458028.png alt></p><p>总结：</p><ol><li>首先请求进入DispatcherServlet 由DispatcherServlet 从HandlerMappings中提取对应的Handler。</li><li>2.此时只是获取到了对应的Handle，然后得去寻找对应的适配器，即：HandlerAdapter。</li><li>拿到对应HandlerAdapter时，这时候开始调用对应的Handler处理业务逻辑了。 （这时候实际上已经执行完了我们的Controller） 执行完成之后返回一个ModeAndView</li><li>这时候交给我们的ViewResolver通过视图名称查找出对应的视图然后返回。</li><li>最后 渲染视图 返回渲染后的视图 &ndash;>响应请求。</li></ol><h2 id=初始化过程>初始化过程<a href=#初始化过程 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>version 5.3.8</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.HttpServletBean#init</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>() <span style=color:#66d9ef>throws</span> ServletException {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 子类实现,初始化web环境</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Let subclasses do whatever initialization they like.</span>
</span></span><span style=display:flex><span>  initServletBean();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.FrameworkServlet#initServletBean</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initServletBean</span>() <span style=color:#66d9ef>throws</span> ServletException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化spring上下文</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>webApplicationContext</span> <span style=color:#f92672>=</span> initWebApplicationContext();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 子类实现</span>
</span></span><span style=display:flex><span>    initFrameworkServlet();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> WebApplicationContext <span style=color:#a6e22e>initWebApplicationContext</span>() {
</span></span><span style=display:flex><span>		WebApplicationContext rootContext <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>				WebApplicationContextUtils.<span style=color:#a6e22e>getWebApplicationContext</span>(getServletContext());
</span></span><span style=display:flex><span>		WebApplicationContext wac <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>webApplicationContext</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// A context instance was injected at construction time -&gt; use it</span>
</span></span><span style=display:flex><span>			wac <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>webApplicationContext</span>;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (wac <span style=color:#66d9ef>instanceof</span> ConfigurableWebApplicationContext) {
</span></span><span style=display:flex><span>				ConfigurableWebApplicationContext cwac <span style=color:#f92672>=</span> (ConfigurableWebApplicationContext) wac;
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cwac.<span style=color:#a6e22e>isActive</span>()) {
</span></span><span style=display:flex><span>					<span style=color:#75715e>// The context has not yet been refreshed -&gt; provide services such as</span>
</span></span><span style=display:flex><span>					<span style=color:#75715e>// setting the parent context, setting the application context id, etc</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> (cwac.<span style=color:#a6e22e>getParent</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>						<span style=color:#75715e>// The context instance was injected without an explicit parent -&gt; set</span>
</span></span><span style=display:flex><span>						<span style=color:#75715e>// the root application context (if any; may be null) as the parent</span>
</span></span><span style=display:flex><span>						cwac.<span style=color:#a6e22e>setParent</span>(rootContext);
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>          
</span></span><span style=display:flex><span>          <span style=color:#75715e>//配置和刷新spring容器（重要）</span>
</span></span><span style=display:flex><span>					<span style=color:#75715e>//这个无非就是初始化spring ioc的环境，创建bean和实例化bean等操作</span>
</span></span><span style=display:flex><span>					<span style=color:#75715e>//这个方法最终也是调用refresh()方法，已在spring源码解析中解析过了</span>
</span></span><span style=display:flex><span>					configureAndRefreshWebApplicationContext(cwac);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (wac <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// No context instance was injected at construction time -&gt; see if one</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// has been registered in the servlet context. If one exists, it is assumed</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// that the parent context (if any) has already been set and that the</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// user has performed any initialization such as setting the context id</span>
</span></span><span style=display:flex><span>			wac <span style=color:#f92672>=</span> findWebApplicationContext();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (wac <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// No context instance is defined for this servlet -&gt; create a local one</span>
</span></span><span style=display:flex><span>			wac <span style=color:#f92672>=</span> createWebApplicationContext(rootContext);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>refreshEventReceived</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Either the context is not a ConfigurableApplicationContext with refresh</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// support or the context injected at construction time had already been</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// refreshed -&gt; trigger initial onRefresh manually here.</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>synchronized</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>onRefreshMonitor</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 初始化DispatcherServlet的配置initStrategies()</span>
</span></span><span style=display:flex><span>				onRefresh(wac);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>publishContext</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Publish the context as a servlet context attribute.</span>
</span></span><span style=display:flex><span>			String attrName <span style=color:#f92672>=</span> getServletContextAttributeName();
</span></span><span style=display:flex><span>			getServletContext().<span style=color:#a6e22e>setAttribute</span>(attrName, wac);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> wac;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.DispatcherServlet#onRefresh	</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onRefresh</span>(ApplicationContext context) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// //初始化springmvc的配置</span>
</span></span><span style=display:flex><span>		initStrategies(context);
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>总体流程:</p><ul><li><p>执行DispatcherServlet的init()方法，</p></li><li><p>会执行父类的HttpServletBean的init()方法</p></li><li><p>然后调用了FrameworkServlet的initServletBean()方法</p></li></ul><blockquote><p>没看懂,执行initWebApplicationContext()方法，就是对spring ioc环境的初始化。那么这里就衍生出了一个面试题：spring容器和spring mvc的容器的区别？通过源码的分析，spring和spring mvc底层，都是调用了同一个refresh()方法，所以spring容器和spring mvc容器是没有区别的，都是指的是同一个容器。</p><p>（3）执行到onRefresh()方法，就是开始初始化DispatcherServlet了，也就是开始初始化spring mvc。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.DispatcherServlet#initStrategies	</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initStrategies</span>(ApplicationContext context) {
</span></span><span style=display:flex><span>  	<span style=color:#75715e>//上传文件</span>
</span></span><span style=display:flex><span>		initMultipartResolver(context);
</span></span><span style=display:flex><span>  	<span style=color:#75715e>//国际化</span>
</span></span><span style=display:flex><span>		initLocaleResolver(context);
</span></span><span style=display:flex><span>  	<span style=color:#75715e>//前段的主题样式</span>
</span></span><span style=display:flex><span>		initThemeResolver(context);
</span></span><span style=display:flex><span>  	<span style=color:#75715e>//初始化HandlerMappings（请求映射器）重点</span>
</span></span><span style=display:flex><span>		initHandlerMappings(context);
</span></span><span style=display:flex><span>  	<span style=color:#75715e>// 初始化HandlerAdapters（处理适配器）</span>
</span></span><span style=display:flex><span>		initHandlerAdapters(context);
</span></span><span style=display:flex><span>		initHandlerExceptionResolvers(context);
</span></span><span style=display:flex><span>		initRequestToViewNameTranslator(context);
</span></span><span style=display:flex><span>  	<span style=color:#75715e>//视图转换器</span>
</span></span><span style=display:flex><span>		initViewResolvers(context);
</span></span><span style=display:flex><span>  	<span style=color:#75715e>//重定向数据管理器</span>
</span></span><span style=display:flex><span>		initFlashMapManager(context);
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.DispatcherServlet#initHandlerMappings</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initHandlerMappings</span>(ApplicationContext context) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Ensure we have at least one HandlerMapping, by registering</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// a default HandlerMapping if no other mappings are found.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 通过配置文件中的配置信息，得到handlerMappings</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappings</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappings</span> <span style=color:#f92672>=</span> getDefaultStrategies(context, HandlerMapping.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>      logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;No HandlerMappings declared for servlet &#39;&#34;</span> <span style=color:#f92672>+</span> getServletName() <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;&#39;: using default strategies from DispatcherServlet.properties&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.DispatcherServlet#getDefaultStrategies</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DEFAULT_STRATEGIES_PATH <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;DispatcherServlet.properties&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getDefaultStrategies</span>(ApplicationContext context, Class<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> strategyInterface) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>if</span> (defaultStrategies <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Load default strategy implementations from properties file.</span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// This is currently strictly internal and not meant to be customized</span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// by application developers.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 从属性文件加载默认策略实现
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 说白了这里的意思就是从DEFAULT_STRATEGIES_PATH这个文件当中拿出所有的配置
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 可以去数一下一共有8个： DispatcherServlet.properties == DEFAULT_STRATEGIES_PATH
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>				ClassPathResource resource <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>				defaultStrategies <span style=color:#f92672>=</span> PropertiesLoaderUtils.<span style=color:#a6e22e>loadProperties</span>(resource);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>catch</span> (IOException ex) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException(<span style=color:#e6db74>&#34;Could not load &#39;&#34;</span> <span style=color:#f92672>+</span> DEFAULT_STRATEGIES_PATH <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39;: &#34;</span> <span style=color:#f92672>+</span> ex.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		String key <span style=color:#f92672>=</span> strategyInterface.<span style=color:#a6e22e>getName</span>(); 
</span></span><span style=display:flex><span>  	<span style=color:#75715e>// defaultStrategies 是DispatcherServlet.properties 配置文件,在static静态代码块初始化</span>
</span></span><span style=display:flex><span>  	<span style=color:#75715e>// 版本变了,不是从静态方法中获取到的</span>
</span></span><span style=display:flex><span>		String value <span style=color:#f92672>=</span> defaultStrategies.<span style=color:#a6e22e>getProperty</span>(key);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (value <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			String<span style=color:#f92672>[]</span> classNames <span style=color:#f92672>=</span> StringUtils.<span style=color:#a6e22e>commaDelimitedListToStringArray</span>(value);
</span></span><span style=display:flex><span>			List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> strategies <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>(classNames.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> (String className : classNames) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 获取class字节码文件</span>
</span></span><span style=display:flex><span>					Class<span style=color:#f92672>&lt;?&gt;</span> clazz <span style=color:#f92672>=</span> ClassUtils.<span style=color:#a6e22e>forName</span>(className, DispatcherServlet.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getClassLoader</span>());
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 底层是通过调用spring的getBean的方式创建该对象（可以进行bean的属性装配）</span>
</span></span><span style=display:flex><span>					<span style=color:#75715e>// 请求映射就是在这个方法实现装配的</span>
</span></span><span style=display:flex><span>					Object strategy <span style=color:#f92672>=</span> createDefaultStrategy(context, clazz);
</span></span><span style=display:flex><span>					strategies.<span style=color:#a6e22e>add</span>((T) strategy);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>catch</span> (ClassNotFoundException ex) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BeanInitializationException(
</span></span><span style=display:flex><span>							<span style=color:#e6db74>&#34;Could not find DispatcherServlet&#39;s default strategy class [&#34;</span> <span style=color:#f92672>+</span> className <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>							<span style=color:#e6db74>&#34;] for interface [&#34;</span> <span style=color:#f92672>+</span> key <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>, ex);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>catch</span> (LinkageError err) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BeanInitializationException(
</span></span><span style=display:flex><span>							<span style=color:#e6db74>&#34;Unresolvable class definition for DispatcherServlet&#39;s default strategy class [&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>							className <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;] for interface [&#34;</span> <span style=color:#f92672>+</span> key <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>, err);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> strategies;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> Collections.<span style=color:#a6e22e>emptyList</span>();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>DispatcherServlet.properties</p><p>从DispatcherServlet.properties配置文件，可以看出handlerMapping默认是有两个：</p><p>1.BeanNameUrlHandlerMapping （主要处理object）</p><p>2.RequestMappingHandlerMapping（主要处理method）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># Default implementation classes for DispatcherServlet&#39;s strategy interfaces.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Used as fallback when no matching beans are found in the DispatcherServlet context.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Not meant to be customized by application developers.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>org.springframework.web.servlet.LocaleResolver</span><span style=color:#f92672>=</span><span style=color:#e6db74>org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>org.springframework.web.servlet.ThemeResolver</span><span style=color:#f92672>=</span><span style=color:#e6db74>org.springframework.web.servlet.theme.FixedThemeResolver</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>//</span> <span style=color:#e6db74>HandlerMapping</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>org.springframework.web.servlet.HandlerMapping</span><span style=color:#f92672>=</span><span style=color:#e6db74>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	org.springframework.web.servlet.function.support.RouterFunctionMapping</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>//</span> <span style=color:#e6db74>HandlerAdapter</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>org.springframework.web.servlet.HandlerAdapter</span><span style=color:#f92672>=</span><span style=color:#e6db74>org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>org.springframework.web.servlet.HandlerExceptionResolver</span><span style=color:#f92672>=</span><span style=color:#e6db74>org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>org.springframework.web.servlet.RequestToViewNameTranslator</span><span style=color:#f92672>=</span><span style=color:#e6db74>org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>org.springframework.web.servlet.ViewResolver</span><span style=color:#f92672>=</span><span style=color:#e6db74>org.springframework.web.servlet.view.InternalResourceViewResolver</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>org.springframework.web.servlet.FlashMapManager</span><span style=color:#f92672>=</span><span style=color:#e6db74>org.springframework.web.servlet.support.SessionFlashMapManager</span>
</span></span></code></pre></div><p>(1) initHandlerMappings方法，就是初始化我们的handlerMapping（请求映射器）。</p><p>(2) handlerMapping的主要作用是，找到请求路径对应的controller的方法。</p><blockquote><p>例如：请求的路径 &ldquo;/index&rdquo;，然后这个handlerMapping，在初始化的时候，已经将所有controller的请求路径映射保存在一个map集合，当请求过来的时候，就将"/index"作为一个key，从map集合中找到对应的controller的index方法。</p></blockquote><p>(3) 这里初始化handlerMappings ，默认是有两个handlerMappings ，是直接在defaultStrategies配置文件中获取。</p><p>(4) 那么defaultStrategies的值是什么时候初始化的呢？</p><blockquote><p>通过查看源码，defaultStrategies这个值，是DispatcherServlet类的静态代码块初始化的。 全世界都知道，当一个类被初始化的时候，会执行该类的static静态代码块的。</p></blockquote><h2 id=请求阶段分析>请求阶段分析<a href=#请求阶段分析 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>用户的一个请求过来，会由servlet接收到，然后一步一步调用到DispatcherServlet的doService方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.DispatcherServlet#doService</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doService</span>(HttpServletRequest request, HttpServletResponse response) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 核心方法（重点）</span>
</span></span><span style=display:flex><span>    doDispatch(request, response);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.DispatcherServlet#doDispatch</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doDispatch</span>(HttpServletRequest request, HttpServletResponse response) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>		HttpServletRequest processedRequest <span style=color:#f92672>=</span> request;
</span></span><span style=display:flex><span>		HandlerExecutionChain mappedHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>boolean</span> multipartRequestParsed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  	<span style=color:#75715e>// 异步编程</span>
</span></span><span style=display:flex><span>		WebAsyncManager asyncManager <span style=color:#f92672>=</span> WebAsyncUtils.<span style=color:#a6e22e>getAsyncManager</span>(request);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 定义变量,哈哈哈,好熟悉呀</span>
</span></span><span style=display:flex><span>			ModelAndView mv <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>			Exception dispatchException <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//检查请求中是否有文件上传操作</span>
</span></span><span style=display:flex><span>				processedRequest <span style=color:#f92672>=</span> checkMultipart(request);
</span></span><span style=display:flex><span>				multipartRequestParsed <span style=color:#f92672>=</span> (processedRequest <span style=color:#f92672>!=</span> request);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Determine handler for the current request.</span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 确定当前请求的处理程序（重点），推断controller和handler的类型，</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 进到这里的getHandler方法</span>
</span></span><span style=display:flex><span>				mappedHandler <span style=color:#f92672>=</span> getHandler(processedRequest);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (mappedHandler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>					noHandlerFound(processedRequest, response);
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Determine handler adapter for the current request.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//推断适配器，不同的controller类型，交给不同的适配器去处理</span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>//如果是一个bean，mappedHandler.getHandler()返回的是一个对象</span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>//如果是一个method，mappedHandler.getHandler()返回的是一个方法	</span>
</span></span><span style=display:flex><span>				HandlerAdapter ha <span style=color:#f92672>=</span> getHandlerAdapter(mappedHandler.<span style=color:#a6e22e>getHandler</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>//到这里，spring才确定我要怎么反射调用</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Process last-modified header, if supported by the handler.</span>
</span></span><span style=display:flex><span>				String method <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getMethod</span>();
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>boolean</span> isGet <span style=color:#f92672>=</span> HttpMethod.<span style=color:#a6e22e>GET</span>.<span style=color:#a6e22e>matches</span>(method);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (isGet <span style=color:#f92672>||</span> HttpMethod.<span style=color:#a6e22e>HEAD</span>.<span style=color:#a6e22e>matches</span>(method)) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>long</span> lastModified <span style=color:#f92672>=</span> ha.<span style=color:#a6e22e>getLastModified</span>(request, mappedHandler.<span style=color:#a6e22e>getHandler</span>());
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>new</span> ServletWebRequest(request, response).<span style=color:#a6e22e>checkNotModified</span>(lastModified) <span style=color:#f92672>&amp;&amp;</span> isGet) {
</span></span><span style=display:flex><span>						<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 前置拦截器处理</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>mappedHandler.<span style=color:#a6e22e>applyPreHandle</span>(processedRequest, response)) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>//通过适配器，处理请求（可以理解为，反射调用方法）（重点）</span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Actually invoke the handler.</span>
</span></span><span style=display:flex><span>				mv <span style=color:#f92672>=</span> ha.<span style=color:#a6e22e>handle</span>(processedRequest, response, mappedHandler.<span style=color:#a6e22e>getHandler</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (asyncManager.<span style=color:#a6e22e>isConcurrentHandlingStarted</span>()) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				applyDefaultViewName(processedRequest, mv);
</span></span><span style=display:flex><span>				mappedHandler.<span style=color:#a6e22e>applyPostHandle</span>(processedRequest, response, mv);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>catch</span> (Exception ex) {
</span></span><span style=display:flex><span>				dispatchException <span style=color:#f92672>=</span> ex;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>catch</span> (Throwable err) {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// As of 4.3, we&#39;re processing Errors thrown from handler methods as well,</span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// making them available for @ExceptionHandler methods and other scenarios.</span>
</span></span><span style=display:flex><span>				dispatchException <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NestedServletException(<span style=color:#e6db74>&#34;Handler dispatch failed&#34;</span>, err);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>catch</span> (Exception ex) {
</span></span><span style=display:flex><span>			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>catch</span> (Throwable err) {
</span></span><span style=display:flex><span>			triggerAfterCompletion(processedRequest, response, mappedHandler,
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>new</span> NestedServletException(<span style=color:#e6db74>&#34;Handler processing failed&#34;</span>, err));
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>通过对DispatcherServlet的分析，得到请求的核心处理方法是doDispatch()，</p><p>主要是分了几步：</p><p>(1) 检查请求中是否有文件上传操作</p><p>(2) 确定当前请求的处理的handler（重点）</p><p>(3) 推断适配器，不同的controller类型，交给不同的适配器去处理</p><p>(4) 执行前置拦截器处理interceptor</p><p>(5) 通过找到的HandlerAdapter ，反射执行相关的业务代码controller的方法。</p><p>(6) 返回结果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.DispatcherServlet#getHandler</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Nullable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> HandlerExecutionChain <span style=color:#a6e22e>getHandler</span>(HttpServletRequest request) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappings</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//循环所有的HandlerMappings</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//this.handlerMappings这个是什么时候初始化的？（重点）</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//在handlerMappings初始化的时候</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (HandlerMapping mapping : <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappings</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>//把请求传过去看能不能得到一个handler</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>//注意：怎么得到handler和handlerMapping自己实现的逻辑有关系</span>
</span></span><span style=display:flex><span>      HandlerExecutionChain handler <span style=color:#f92672>=</span> mapping.<span style=color:#a6e22e>getHandler</span>(request);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (handler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> handler;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Nullable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> HandlerExecutionChain <span style=color:#a6e22e>getHandler</span>(HttpServletRequest request) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//获取handler（重点）</span>
</span></span><span style=display:flex><span>  Object handler <span style=color:#f92672>=</span> getHandlerInternal(request);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (handler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    handler <span style=color:#f92672>=</span> getDefaultHandler();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (handler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Bean name or resolved handler?</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (handler <span style=color:#66d9ef>instanceof</span> String) {
</span></span><span style=display:flex><span>    String handlerName <span style=color:#f92672>=</span> (String) handler;
</span></span><span style=display:flex><span>    handler <span style=color:#f92672>=</span> obtainApplicationContext().<span style=color:#a6e22e>getBean</span>(handlerName);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Ensure presence of cached lookupPath for interceptors and others</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ServletRequestPathUtils.<span style=color:#a6e22e>hasCachedPath</span>(request)) {
</span></span><span style=display:flex><span>    initLookupPath(request);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  HandlerExecutionChain executionChain <span style=color:#f92672>=</span> getHandlerExecutionChain(handler, request);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>    logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;Mapped to &#34;</span> <span style=color:#f92672>+</span> handler);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isDebugEnabled</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>DispatcherType.<span style=color:#a6e22e>ASYNC</span>.<span style=color:#a6e22e>equals</span>(request.<span style=color:#a6e22e>getDispatcherType</span>())) {
</span></span><span style=display:flex><span>    logger.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;Mapped to &#34;</span> <span style=color:#f92672>+</span> executionChain.<span style=color:#a6e22e>getHandler</span>());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (hasCorsConfigurationSource(handler) <span style=color:#f92672>||</span> CorsUtils.<span style=color:#a6e22e>isPreFlightRequest</span>(request)) {
</span></span><span style=display:flex><span>    CorsConfiguration config <span style=color:#f92672>=</span> getCorsConfiguration(handler, request);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (getCorsConfigurationSource() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      CorsConfiguration globalConfig <span style=color:#f92672>=</span> getCorsConfigurationSource().<span style=color:#a6e22e>getCorsConfiguration</span>(request);
</span></span><span style=display:flex><span>      config <span style=color:#f92672>=</span> (globalConfig <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> globalConfig.<span style=color:#a6e22e>combine</span>(config) : config);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (config <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      config.<span style=color:#a6e22e>validateAllowCredentials</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    executionChain <span style=color:#f92672>=</span> getCorsHandlerExecutionChain(request, executionChain, config);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> executionChain;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(1) getHandler()方法，主要是遍历在DispatcherServlet初始化是，初始化的handlerMappings。</p><p>(2) 这个方法的主要思想是，通过request的路径，去匹配对应的controller去处理。</p><p>(3) SpringMVC自己自带了2个HandlerMapping 来供我们选择 至于 为什么要有2个呢？</p><h3 id=两种注册controller的方式>两种注册Controller的方式<a href=#两种注册controller的方式 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>我们用2种方式来注册Controller 分别是：</p><p>(1) 作为Bean的形式：实现Controller接口，重写handleRequest方法，请求路径为"/test"</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>(<span style=color:#e6db74>&#34;/test&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TesrController</span> <span style=color:#66d9ef>implements</span> org.<span style=color:#a6e22e>springframework</span>.<span style=color:#a6e22e>web</span>.<span style=color:#a6e22e>servlet</span>.<span style=color:#a6e22e>mvc</span>.<span style=color:#a6e22e>Controller</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> ModelAndView <span style=color:#a6e22e>handleRequest</span>(HttpServletRequest request, 
</span></span><span style=display:flex><span>	HttpServletResponse	response) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>		System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;1&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(2) 以Annotation形式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Controller</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AnnotationController</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@RequestMapping</span>(<span style=color:#e6db74>&#34;/test2&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>test</span>(){
</span></span><span style=display:flex><span>		System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;test&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>经过测试:</p><p>(1)可以得到以Bean方式的controller，是通过BeanNameUrlHandlerMapping去匹配</p><p>(2)以注解方法的controller，是通过RequestMappingHandlerMapping去匹配</p><h4 id=beannameurlhandlermapping>BeanNameUrlHandlerMapping<a href=#beannameurlhandlermapping class=hanchor arialabel=Anchor>&#8983;</a></h4><p>BeanNameUrlHandlerMapping处理bean方式的源码分析：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#getHandlerInternal</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Nullable</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> Object <span style=color:#a6e22e>getHandlerInternal</span>(HttpServletRequest request) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取请求的路径</span>
</span></span><span style=display:flex><span>		String lookupPath <span style=color:#f92672>=</span> initLookupPath(request);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 到对应的handler（重点）调用 lookupHandler()</span>
</span></span><span style=display:flex><span>		Object handler;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (usesPathPatterns()) {
</span></span><span style=display:flex><span>			RequestPath path <span style=color:#f92672>=</span> ServletRequestPathUtils.<span style=color:#a6e22e>getParsedRequestPath</span>(request);
</span></span><span style=display:flex><span>			handler <span style=color:#f92672>=</span> lookupHandler(path, lookupPath, request);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			handler <span style=color:#f92672>=</span> lookupHandler(lookupPath, request);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (handler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// We need to care for the default handler directly, since we need to</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span>
</span></span><span style=display:flex><span>			Object rawHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (StringUtils.<span style=color:#a6e22e>matchesCharacter</span>(lookupPath, <span style=color:#e6db74>&#39;/&#39;</span>)) {
</span></span><span style=display:flex><span>				rawHandler <span style=color:#f92672>=</span> getRootHandler();
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (rawHandler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>				rawHandler <span style=color:#f92672>=</span> getDefaultHandler();
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (rawHandler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Bean name or resolved handler?</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (rawHandler <span style=color:#66d9ef>instanceof</span> String) {
</span></span><span style=display:flex><span>					String handlerName <span style=color:#f92672>=</span> (String) rawHandler;
</span></span><span style=display:flex><span>					rawHandler <span style=color:#f92672>=</span> obtainApplicationContext().<span style=color:#a6e22e>getBean</span>(handlerName);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				validateHandler(rawHandler, request);
</span></span><span style=display:flex><span>				handler <span style=color:#f92672>=</span> buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> handler;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#lookupHandler(java.lang.String, javax.servlet.http.HttpServletRequest)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Nullable</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> Object <span style=color:#a6e22e>lookupHandler</span>(String lookupPath, HttpServletRequest request) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 查看这里的方法</span>
</span></span><span style=display:flex><span>		Object handler <span style=color:#f92672>=</span> getDirectMatch(lookupPath, request);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (handler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> handler;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Pattern match?</span>
</span></span><span style=display:flex><span>		List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> matchingPatterns <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (String registeredPattern : <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMap</span>.<span style=color:#a6e22e>keySet</span>()) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (getPathMatcher().<span style=color:#a6e22e>match</span>(registeredPattern, lookupPath)) {
</span></span><span style=display:flex><span>				matchingPatterns.<span style=color:#a6e22e>add</span>(registeredPattern);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (useTrailingSlashMatch()) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>registeredPattern.<span style=color:#a6e22e>endsWith</span>(<span style=color:#e6db74>&#34;/&#34;</span>) <span style=color:#f92672>&amp;&amp;</span> getPathMatcher().<span style=color:#a6e22e>match</span>(registeredPattern <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/&#34;</span>, lookupPath)) {
</span></span><span style=display:flex><span>					matchingPatterns.<span style=color:#a6e22e>add</span>(registeredPattern <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/&#34;</span>);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		String bestMatch <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>		Comparator<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> patternComparator <span style=color:#f92672>=</span> getPathMatcher().<span style=color:#a6e22e>getPatternComparator</span>(lookupPath);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>matchingPatterns.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>			matchingPatterns.<span style=color:#a6e22e>sort</span>(patternComparator);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isTraceEnabled</span>() <span style=color:#f92672>&amp;&amp;</span> matchingPatterns.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>&gt;</span> 1) {
</span></span><span style=display:flex><span>				logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;Matching patterns &#34;</span> <span style=color:#f92672>+</span> matchingPatterns);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			bestMatch <span style=color:#f92672>=</span> matchingPatterns.<span style=color:#a6e22e>get</span>(0);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (bestMatch <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMap</span>.<span style=color:#a6e22e>get</span>(bestMatch);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (handler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (bestMatch.<span style=color:#a6e22e>endsWith</span>(<span style=color:#e6db74>&#34;/&#34;</span>)) {
</span></span><span style=display:flex><span>					handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMap</span>.<span style=color:#a6e22e>get</span>(bestMatch.<span style=color:#a6e22e>substring</span>(0, bestMatch.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>-</span> 1));
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (handler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException(
</span></span><span style=display:flex><span>							<span style=color:#e6db74>&#34;Could not find handler for best pattern match [&#34;</span> <span style=color:#f92672>+</span> bestMatch <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Bean name or resolved handler?</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (handler <span style=color:#66d9ef>instanceof</span> String) {
</span></span><span style=display:flex><span>				String handlerName <span style=color:#f92672>=</span> (String) handler;
</span></span><span style=display:flex><span>				handler <span style=color:#f92672>=</span> obtainApplicationContext().<span style=color:#a6e22e>getBean</span>(handlerName);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			validateHandler(handler, request);
</span></span><span style=display:flex><span>			String pathWithinMapping <span style=color:#f92672>=</span> getPathMatcher().<span style=color:#a6e22e>extractPathWithinPattern</span>(bestMatch, lookupPath);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// There might be multiple &#39;best patterns&#39;, let&#39;s make sure we have the correct URI template variables</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// for all of them</span>
</span></span><span style=display:flex><span>			Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> uriTemplateVariables <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> (String matchingPattern : matchingPatterns) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (patternComparator.<span style=color:#a6e22e>compare</span>(bestMatch, matchingPattern) <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>					Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> vars <span style=color:#f92672>=</span> getPathMatcher().<span style=color:#a6e22e>extractUriTemplateVariables</span>(matchingPattern, lookupPath);
</span></span><span style=display:flex><span>					Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> decodedVars <span style=color:#f92672>=</span> getUrlPathHelper().<span style=color:#a6e22e>decodePathVariables</span>(request, vars);
</span></span><span style=display:flex><span>					uriTemplateVariables.<span style=color:#a6e22e>putAll</span>(decodedVars);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isTraceEnabled</span>() <span style=color:#f92672>&amp;&amp;</span> uriTemplateVariables.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>				logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;URI variables &#34;</span> <span style=color:#f92672>+</span> uriTemplateVariables);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// No handler found...</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#getDirectMatch</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Nullable</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> Object <span style=color:#a6e22e>getDirectMatch</span>(String urlPath, HttpServletRequest request) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 通过请求的路径，在handlerMap中去匹配。</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// handlerMap这个值，什么时候填充值？在init初始化的时候，就已经存放在这个handlerMap种</span>
</span></span><span style=display:flex><span>		Object handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMap</span>.<span style=color:#a6e22e>get</span>(urlPath);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (handler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Bean name or resolved handler?</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (handler <span style=color:#66d9ef>instanceof</span> String) {
</span></span><span style=display:flex><span>				String handlerName <span style=color:#f92672>=</span> (String) handler;
</span></span><span style=display:flex><span>				handler <span style=color:#f92672>=</span> obtainApplicationContext().<span style=color:#a6e22e>getBean</span>(handlerName);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			validateHandler(handler, request);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>(1) 以Bean方式的controller，匹配请求的路径，是通过一个handlerMap去匹配，比较简单。</p><p>(2) 这里的问题是，这个handlerMap的值，是什么时候放进去的？</p><blockquote><p>通过源码分析，BeanNameUrlHandlerMapping是实现了ApplicationContextAware接口。 如果你精通spring的源码，就知道spring的实例bean的时候，会回调这些类的setApplicationContext()方法。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.context.support.ApplicationObjectSupport#setApplicationContext</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setApplicationContext</span>(<span style=color:#a6e22e>@Nullable</span> ApplicationContext context) <span style=color:#66d9ef>throws</span> BeansException {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (context <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>isContextRequired()) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Reset internal context state.</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>applicationContext</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>messageSourceAccessor</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>applicationContext</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Initialize with passed-in context.</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>requiredContextClass().<span style=color:#a6e22e>isInstance</span>(context)) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ApplicationContextException(
</span></span><span style=display:flex><span>						<span style=color:#e6db74>&#34;Invalid application context: needs to be of type [&#34;</span> <span style=color:#f92672>+</span> requiredContextClass().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>applicationContext</span> <span style=color:#f92672>=</span> context;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>messageSourceAccessor</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MessageSourceAccessor(context);
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 初始化ApplicationContext，就会执行到子类的方法（重点）</span>
</span></span><span style=display:flex><span>			initApplicationContext(context);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Ignore reinitialization if same context passed in.</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>applicationContext</span> <span style=color:#f92672>!=</span> context) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ApplicationContextException(
</span></span><span style=display:flex><span>						<span style=color:#e6db74>&#34;Cannot reinitialize with different application context: current one is [&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>						<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>applicationContext</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;], passed-in one is [&#34;</span> <span style=color:#f92672>+</span> context <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 没看懂怎么走到这里来呢</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractDetectingUrlHandlerMapping#initApplicationContext</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initApplicationContext</span>() <span style=color:#66d9ef>throws</span> ApplicationContextException {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>initApplicationContext</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检测出handler</span>
</span></span><span style=display:flex><span>		detectHandlers();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractDetectingUrlHandlerMapping#detectHandlers</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>detectHandlers</span>() <span style=color:#66d9ef>throws</span> BeansException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取spring ioc所有的beanName，然后判断beanName，那些是以 &#34;/&#34; 开头</span>
</span></span><span style=display:flex><span>		ApplicationContext applicationContext <span style=color:#f92672>=</span> obtainApplicationContext();
</span></span><span style=display:flex><span>		String<span style=color:#f92672>[]</span> beanNames <span style=color:#f92672>=</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>detectHandlersInAncestorContexts</span> <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>				BeanFactoryUtils.<span style=color:#a6e22e>beanNamesForTypeIncludingAncestors</span>(applicationContext, Object.<span style=color:#a6e22e>class</span>) :
</span></span><span style=display:flex><span>				applicationContext.<span style=color:#a6e22e>getBeanNamesForType</span>(Object.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Take any bean name that we can determine URLs for.</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (String beanName : beanNames) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 然后判断beanName，那些是以 &#34;/&#34; 开头</span>
</span></span><span style=display:flex><span>			String<span style=color:#f92672>[]</span> urls <span style=color:#f92672>=</span> determineUrlsForHandler(beanName);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ObjectUtils.<span style=color:#a6e22e>isEmpty</span>(urls)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册handler（重点）</span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// URL paths found: Let&#39;s consider it a handler.</span>
</span></span><span style=display:flex><span>				registerHandler(urls, beanName);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#registerHandler(java.lang.String[], java.lang.String)	</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerHandler</span>(String<span style=color:#f92672>[]</span> urlPaths, String beanName) <span style=color:#66d9ef>throws</span> BeansException, IllegalStateException {
</span></span><span style=display:flex><span>		Assert.<span style=color:#a6e22e>notNull</span>(urlPaths, <span style=color:#e6db74>&#34;URL path array must not be null&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (String urlPath : urlPaths) {
</span></span><span style=display:flex><span>			registerHandler(urlPath, beanName);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#registerHandler(java.lang.String, java.lang.Object)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerHandler</span>(String urlPath, Object handler) <span style=color:#66d9ef>throws</span> BeansException, IllegalStateException {
</span></span><span style=display:flex><span>		Assert.<span style=color:#a6e22e>notNull</span>(urlPath, <span style=color:#e6db74>&#34;URL path must not be null&#34;</span>);
</span></span><span style=display:flex><span>		Assert.<span style=color:#a6e22e>notNull</span>(handler, <span style=color:#e6db74>&#34;Handler object must not be null&#34;</span>);
</span></span><span style=display:flex><span>		Object resolvedHandler <span style=color:#f92672>=</span> handler;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Eagerly resolve handler if referencing singleton via name.</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lazyInitHandlers</span> <span style=color:#f92672>&amp;&amp;</span> handler <span style=color:#66d9ef>instanceof</span> String) {
</span></span><span style=display:flex><span>			String handlerName <span style=color:#f92672>=</span> (String) handler;
</span></span><span style=display:flex><span>			ApplicationContext applicationContext <span style=color:#f92672>=</span> obtainApplicationContext();
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (applicationContext.<span style=color:#a6e22e>isSingleton</span>(handlerName)) {
</span></span><span style=display:flex><span>				resolvedHandler <span style=color:#f92672>=</span> applicationContext.<span style=color:#a6e22e>getBean</span>(handlerName);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		Object mappedHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMap</span>.<span style=color:#a6e22e>get</span>(urlPath);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (mappedHandler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (mappedHandler <span style=color:#f92672>!=</span> resolvedHandler) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException(
</span></span><span style=display:flex><span>						<span style=color:#e6db74>&#34;Cannot map &#34;</span> <span style=color:#f92672>+</span> getHandlerDescription(handler) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; to URL path [&#34;</span> <span style=color:#f92672>+</span> urlPath <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>						<span style=color:#e6db74>&#34;]: There is already &#34;</span> <span style=color:#f92672>+</span> getHandlerDescription(mappedHandler) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; mapped.&#34;</span>);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (urlPath.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;/&#34;</span>)) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>					logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;Root mapping to &#34;</span> <span style=color:#f92672>+</span> getHandlerDescription(handler));
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				setRootHandler(resolvedHandler);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (urlPath.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;/*&#34;</span>)) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>					logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;Default mapping to &#34;</span> <span style=color:#f92672>+</span> getHandlerDescription(handler));
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				setDefaultHandler(resolvedHandler);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 最终put到map集合中（省略其他无关代码）</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMap</span>.<span style=color:#a6e22e>put</span>(urlPath, resolvedHandler);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (getPatternParser() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>pathPatternHandlerMap</span>.<span style=color:#a6e22e>put</span>(getPatternParser().<span style=color:#a6e22e>parse</span>(urlPath), resolvedHandler);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>					logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;Mapped [&#34;</span> <span style=color:#f92672>+</span> urlPath <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;] onto &#34;</span> <span style=color:#f92672>+</span> getHandlerDescription(handler));
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><blockquote><p>BeanNameUrlHandlerMapping处理bean方式的源码分析，其实是很简单：</p><p>(1) 在类初始化的时候，就已经将所有实现了Controller接口的controller类，拿到他们的@Componet(&rsquo;/test')</p><p>(2) 然后将&rsquo;/test&rsquo;这个作为key，controller类作为value，放入到一个map集合。</p><p>(3) 当一个请求过来的时候，拿到这个请求的uri，在map里面找，找到了即表示匹配上</p></blockquote><h4 id=requestmappinghandlermapping>RequestMappingHandlerMapping<a href=#requestmappinghandlermapping class=hanchor arialabel=Anchor>&#8983;</a></h4><p>处理注解方式的源码分析：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getHandlerInternal</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 对于RequestMappingHandlerMapping，indexController.index()，方法的请求路径映射</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Nullable</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> HandlerMethod <span style=color:#a6e22e>getHandlerInternal</span>(HttpServletRequest request) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取请求路径</span>
</span></span><span style=display:flex><span>		String lookupPath <span style=color:#f92672>=</span> initLookupPath(request);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mappingRegistry</span>.<span style=color:#a6e22e>acquireReadLock</span>();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 通过请求路径，获取handler</span>
</span></span><span style=display:flex><span>			HandlerMethod handlerMethod <span style=color:#f92672>=</span> lookupHandlerMethod(lookupPath, request);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> (handlerMethod <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> handlerMethod.<span style=color:#a6e22e>createWithResolvedBean</span>() : <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mappingRegistry</span>.<span style=color:#a6e22e>releaseReadLock</span>();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#lookupHandlerMethod</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Nullable</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> HandlerMethod <span style=color:#a6e22e>lookupHandlerMethod</span>(String lookupPath, HttpServletRequest request) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>		List<span style=color:#f92672>&lt;</span>Match<span style=color:#f92672>&gt;</span> matches <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从mappingRegistry的urlLookup，匹配请求路径</span>
</span></span><span style=display:flex><span>		List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> directPathMatches <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mappingRegistry</span>.<span style=color:#a6e22e>getMappingsByDirectPath</span>(lookupPath);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (directPathMatches <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			addMatchingMappings(directPathMatches, matches, request);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (matches.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>			addMatchingMappings(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mappingRegistry</span>.<span style=color:#a6e22e>getRegistrations</span>().<span style=color:#a6e22e>keySet</span>(), matches, request);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>matches.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>			Match bestMatch <span style=color:#f92672>=</span> matches.<span style=color:#a6e22e>get</span>(0);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (matches.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>&gt;</span> 1) {
</span></span><span style=display:flex><span>				Comparator<span style=color:#f92672>&lt;</span>Match<span style=color:#f92672>&gt;</span> comparator <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MatchComparator(getMappingComparator(request));
</span></span><span style=display:flex><span>				matches.<span style=color:#a6e22e>sort</span>(comparator);
</span></span><span style=display:flex><span>				bestMatch <span style=color:#f92672>=</span> matches.<span style=color:#a6e22e>get</span>(0);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>					logger.<span style=color:#a6e22e>trace</span>(matches.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; matching mappings: &#34;</span> <span style=color:#f92672>+</span> matches);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (CorsUtils.<span style=color:#a6e22e>isPreFlightRequest</span>(request)) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>for</span> (Match match : matches) {
</span></span><span style=display:flex><span>						<span style=color:#66d9ef>if</span> (match.<span style=color:#a6e22e>hasCorsConfig</span>()) {
</span></span><span style=display:flex><span>							<span style=color:#66d9ef>return</span> PREFLIGHT_AMBIGUOUS_MATCH;
</span></span><span style=display:flex><span>						}
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>					Match secondBestMatch <span style=color:#f92672>=</span> matches.<span style=color:#a6e22e>get</span>(1);
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> (comparator.<span style=color:#a6e22e>compare</span>(bestMatch, secondBestMatch) <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>						Method m1 <span style=color:#f92672>=</span> bestMatch.<span style=color:#a6e22e>getHandlerMethod</span>().<span style=color:#a6e22e>getMethod</span>();
</span></span><span style=display:flex><span>						Method m2 <span style=color:#f92672>=</span> secondBestMatch.<span style=color:#a6e22e>getHandlerMethod</span>().<span style=color:#a6e22e>getMethod</span>();
</span></span><span style=display:flex><span>						String uri <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getRequestURI</span>();
</span></span><span style=display:flex><span>						<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException(
</span></span><span style=display:flex><span>								<span style=color:#e6db74>&#34;Ambiguous handler methods mapped for &#39;&#34;</span> <span style=color:#f92672>+</span> uri <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39;: {&#34;</span> <span style=color:#f92672>+</span> m1 <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>+</span> m2 <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;}&#34;</span>);
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			request.<span style=color:#a6e22e>setAttribute</span>(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.<span style=color:#a6e22e>getHandlerMethod</span>());
</span></span><span style=display:flex><span>			handleMatch(bestMatch.<span style=color:#a6e22e>mapping</span>, lookupPath, request);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 返回handler</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> bestMatch.<span style=color:#a6e22e>getHandlerMethod</span>();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> handleNoMatch(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mappingRegistry</span>.<span style=color:#a6e22e>getRegistrations</span>().<span style=color:#a6e22e>keySet</span>(), lookupPath, request);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 3.AbstractHandlerMethodMapping.MappingRegistry#getMappingsByDirectPath</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Nullable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getMappingsByDirectPath</span>(String urlPath) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>pathLookup</span>.<span style=color:#a6e22e>get</span>(urlPath);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>RequestMappingHandlerMapping处理注解方式的源码分析，比较复杂，用一个MappingRegistry维护所有的请求路径映射。</p><p>MappingRegistry的初始化，也是在该bean实例化的时候，就已经做好的了。</p><p>原理也是和上一个差不多，都是从一个map集合里面匹配。所以这里就不再做解析了</p><blockquote><p>总结：getHandler()</p></blockquote><p>找适配器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> HandlerAdapter <span style=color:#a6e22e>getHandlerAdapter</span>(Object handler) <span style=color:#66d9ef>throws</span> ServletException {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerAdapters</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> (HandlerAdapter adapter : <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerAdapters</span>) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (adapter.<span style=color:#a6e22e>supports</span>(handler)) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> adapter;
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ServletException(<span style=color:#e6db74>&#34;No adapter for handler [&#34;</span> <span style=color:#f92672>+</span> handler <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>				<span style=color:#e6db74>&#34;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><blockquote><p>其实能看见他是从一个handlerAdapters属性里面遍历了我们的适配器 这个handlerAdapters哪来的呢？</p><p>跟我们的HandlerMappings一样 在他的配置文件里面有写，就是我们刚刚所说的 。</p><p>至于什么是适配器，我们结合Handler来讲， 就如我们在最开始的总结时所说的， 一开始只是找到了Handler 现在要执行了，但是有个问题，Handler不止一个， 自然而然对应的执行方式就不同了， 这时候适配器的概念就出来了：对应不同的Handler的执行方案。当找到合适的适配器的时候， 基本上就已经收尾了，因为后面在做了一些判断之后（判断请求类型之类的），就开始执行了你的Handler了，上代码：</p><p><code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code></p><p>这个mv就是我们的ModlAndView 其实执行完这一行 我们的Controller的逻辑已经执行完了， 剩下的就是寻找视图 渲染图的事情了。</p></blockquote><blockquote><p>总结： 其实我们的SpringMVC关键的概念就在于Handler（处理器） 和Adapter(适配器) 通过一个关键的HandlerMappings 找到合适处理你的Controller的Handler 然后再通过HandlerAdapters找到一个合适的HandlerAdapter 来执行Handler即Controller里面的逻辑。 最后再返回ModlAndView&mldr;</p></blockquote><blockquote><p>参考:https://juejin.cn/post/6991290858880368676</p></blockquote><h1 id=spring>Spring<a href=#spring class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=事务的传播>事务的传播<a href=#事务的传播 class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>参考:https://segmentfault.com/a/1190000013341344</p></blockquote><table><thead><tr><th>传播等级</th><th>描述</th><th>理解</th></tr></thead><tbody><tr><td>REQUIRED</td><td>默认的事务传播级别<br>表示如果当前存在事务，则加入该事务；<br>如果当前没有事务，则创建一个新的事务。</td><td>A有事务,B就跟着用<br>A没有事务,B就开启自己的事务,只B方法用</td></tr><tr><td>SUPPORTS</td><td>如果当前存在事务，则加入该事务；<br>如果当前没有事务，则以非事务的方式继续运行。</td><td></td></tr><tr><td>MANDATORY</td><td>如果当前存在事务，则加入该事务；<br>如果当前没有事务，则抛出异常。</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>REQUIRES_NEW</td><td>表示创建一个新的事务<br>如果当前存在事务，则把当前事务挂起。<br>也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</td><td></td></tr><tr><td>NOT_SUPPORTED</td><td>以非事务方式运行，<br>如果当前存在事务，则把当前事务挂起。</td><td></td></tr><tr><td>NEVER</td><td>以非事务方式运行，<br>如果当前存在事务，则抛出异常。</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>NESTED</td><td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；<br>如果当前没有事务，则该取值等价于REQUIRED。</td><td></td></tr></tbody></table><p>默认数据是anthony和0</p><p><strong>REQUIRED</strong></p><p>A方法<code>有</code>事务,A方法报错,有一个报错都会回滚,结果是:anthony和0</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRED</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A方法<code>没有</code>事务,A方法有报错,结果是:anthony2和1</p><p>B方法自己开启事务,就不管A事务了,所以A方法,就算报错了,也成功写入数据库,B事务没有报错,也成功写入数据库</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRED</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A方法没有事务,A方法和B方法都报错,,结果是:anthony2和0</p><p>A方法没有事务,所以A方法插入数据库成功,就算报错,也没有回滚</p><p>B方法自己开始事务,B方法报错,所以回滚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRED</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>SUPPORTS</strong></p><p>A方法有事务,A方法报错,都回滚,,结果是:anthony和0</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>SUPPORTS</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A没有事务,,A方法报错,都没有回滚,结果是:anthony2和1</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>SUPPORTS</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A没有事务,,A,B方法都报错,都没有回滚,结果是:anthony2和1</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>SUPPORTS</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>MANDATORY</strong></p><p>A有事务,A报错,都回滚,结果是:anthony和0</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>MANDATORY</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A没有事务,运行报错了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>MANDATORY</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>REQUIRES_NEW</strong></p><p>测试的时候,不要操作同一条数据,容易超时&mldr;..</p><p>A开始事务,B也开始事务,B报错了,B回滚,A插入成功</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样没有复现出问题</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>A没有事务,B有事务</li><li>A报错,没有回滚,
B插入数据成功</li><li><code>外围方法异常,不影响内部调用的方法</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>A没有事务,B有事务</li><li>A插入数据成功,B回滚</li><li><code>内部调用的方法,不影响外围的方法成功插入</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>NOT_SUPPORTED</strong></p><p>A有事务,B也有事务,A回滚了,B报错了,没有回滚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>NOT_SUPPORTED</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A有事务,B也有事务,A回滚了,B没有回滚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>NOT_SUPPORTED</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>NEVER</strong></p><p>直接报错</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>        Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>        byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>        byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>        transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>NEVER</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>        Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>        byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>        byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>NESTED</strong></p><p>全部提交成功</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>NESTED</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>全部失败</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>NESTED</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A没有事务,B有事务</p><p>A执行成功,B回滚成功</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;anthony2&#34;</span>);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    transactionalController.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(propagation<span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>NESTED</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>(){
</span></span><span style=display:flex><span>    Test byId <span style=color:#f92672>=</span> testService.<span style=color:#a6e22e>getById</span>(2);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>setParentId</span>(1);
</span></span><span style=display:flex><span>    byId.<span style=color:#a6e22e>updateById</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 <span style=color:#f92672>/</span> 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=拦截器和过滤器>拦截器和过滤器<a href=#拦截器和过滤器 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>1、过滤器和拦截器<strong>触发时机不一样</strong>，先拦截器,后过滤器</p><p>2、<strong>拦截器</strong>可以获取IOC容器中的各个bean，而过滤器就不行，因为拦<strong>截器是spring提供并管理的</strong>，spring的功能可以被拦截器使用，在拦截器里注入一个service，可以调用业务逻辑。而过滤器是JavaEE标准，只需依赖servlet api ，不需要依赖spring。</p><p>3、<strong>过滤器的实现</strong>基于<strong>回调函数</strong>。而<strong>拦截器</strong>（代理模式）的实现<strong>基于反射</strong></p><p>4、<strong>过滤器</strong>是依<strong>赖于Servlet容</strong>器，<strong>属于Servlet规范的一部分</strong>，而<strong>拦截器则是独立存</strong>在的，可以在任何情况下使用。</p><p>5、<strong>Filte</strong>r的执行由<strong>Servlet容器回调完成</strong>，而<strong>拦截器</strong>通常通**过动态代理（反射）**的方式来执行。</p><p>6、<strong>Filter的生命周</strong>期<strong>由Servlet容器管理</strong>，而<strong>拦截器则</strong>可以通过I<strong>oC容器来管理</strong>，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。</p><p>7、<strong>过滤器只能在请求的前后使用，而拦截器可以详细到每个方法</strong>
<img src=https://image.runtimes.cc/202404051459166.png alt></p><h1 id=spring-ioc>Spring IOC<a href=#spring-ioc class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Spring提供了两种容器：BeanFactory和ApplicationContext</p><ul><li>**BeanFactory：**基本的IoC容器，默认采用延迟初始化策略（lazy-load），即只有当客户端对象需要访问容器中某个bean对象的时候，才会对该bean对象进行初始化以及依赖注入操作。所以BeanFactory容器的特点是启动初期速度快，所需资源有限，适合于资源有限功能要求不严格的场景。</li><li><strong>ApplicationContext：</strong> ApplicationContext在BeanFactory基础上构建，支持其他的高级特性，如国际化，事件发布等。相对于BeanFactory容器来说，ApplicationContext在启动的时候即完成资源的初始化，所以启动时间较长，适合于系统资源充足，需要更多功能的场景</li></ul><h1 id=spring-bean>Spring Bean<a href=#spring-bean class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Java 中Bean的定义：</p><ul><li>类中所有的属性都必须封装，即：使用private声明；<code>这个不太确定</code></li><li>封装的属性如果需要被外部所操作，则必须编写对应的setter、getter方法；</li><li>一个JavaBean中至少存在一个无参构造方法。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Staff</span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span>(<span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而Spring IoC容器就是管理bean的工厂。Spring中bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的。Spring可以采用XML配置文件的方式来管理和配置Bean信息，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;beans</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>xmlns:xsi=</span><span style=color:#e6db74>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>xsi:schemaLocation=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;user&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;com.wgs.spring.bean.User&#34;</span><span style=color:#f92672>&gt;&lt;/bean&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/beans&gt;</span>
</span></span></code></pre></div><p><code>&lt;beans></code>是XML配置文件中根节点，下面可包含多个<code>&lt;bean></code>子节点。Spring的XML配置文件中的配置与<code>&lt;bean></code>元素是一一对应的。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>注册到容器的对象都有一个唯一的id值，如id=&ldquo;user&rdquo;</td></tr><tr><td>name</td><td>bean的别名,name可以使用逗号、空格或冒号等分割指定多个name，而id就不可以</td></tr><tr><td>scope</td><td>作用域</td></tr><tr><td>constructor-arg</td><td>用来注入依赖关系</td></tr><tr><td>properties</td><td>用来注入依赖关系</td></tr><tr><td>autowiring mode</td><td>用来注入依赖关系</td></tr><tr><td>lazy-initialization mode</td><td>是否延迟加载</td></tr><tr><td>initialization method</td><td>bean被创建的时候,初始化的的方法</td></tr><tr><td>destruction method</td><td>销毁指定的方法</td></tr></tbody></table><p><img src=https://image.runtimes.cc/202404051459690.png alt></p><p><img src=https://image.runtimes.cc/202404051458611.png alt></p><h1 id=spring-bean-生命周期>Spring Bean 生命周期<a href=#spring-bean-生命周期 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>2.低昂registerBeanFactoryPostProcessor  完成扫描,运行之前,不会有我们自己的类,除了<code>@componentScan</code>这个注解的这个类,等完成之后,就会有我们自己的类</p><p>1：实例化一个ApplicationContext的对象；2：调用bean工厂后置处理器完成扫描；3：循环解析扫描出来的类信息；4：实例化一个BeanDefinition对象来存储解析出来的信息；5：把实例化好的beanDefinition对象put到<code>beanDefinitionMap</code>当中缓存起来，以便后面实例化bean；6：再次调用bean工厂后置处理器；7：当然spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么这一步就是spring调用<code>finishBeanFactoryInitialization</code>方法来实例化单例的bean，实例化之前spring要做验证，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否abstract等等；8：如果验证完成spring在实例化一个bean之前需要推断构造方法，因为spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法；9：推断完构造方法之后spring调用构造方法反射实例化一个<strong>对象</strong>；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来的对象属性是没有注入，所以不是一个完整的bean；10：spring处理合并后的beanDefinition(合并？是spring当中非常重要的一块内容，后面的文章我会分析)；11：判断是否支持循环依赖，如果支持则提前把一个工厂存入singletonFactories——map；12：判断是否需要完成属性注入13：如果需要完成属性注入，则开始注入属性14：判断bean的类型回调Aware接口15：调用生命周期回调方法16：如果需要代理则完成代理17：put到单例池——bean完成——存在spring容器当中</p><h1 id=spring-bean-循环依赖>Spring Bean 循环依赖<a href=#spring-bean-循环依赖 class=hanchor arialabel=Anchor>&#8983;</a></h1><p><a href=https://juejin.im/post/6844904166351978504#h5>https://juejin.im/post/6844904166351978504#h5</a></p><p>AnnotationConfigApplicationContext#AnnotationConfigApplicationContext</p><pre tabindex=0><code>public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) {
    this();
    register(componentClasses);
    // 关键方法
    refresh();
}
</code></pre><p>org.springframework.context.support.AbstractApplicationContext#refresh</p><pre tabindex=0><code>@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // Prepare this context for refreshing.
        prepareRefresh();

        // Tell the subclass to refresh the internal bean factory.
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // Prepare the bean factory for use in this context.
        prepareBeanFactory(beanFactory);

        try {
            // Allows post-processing of the bean factory in context subclasses.
            postProcessBeanFactory(beanFactory);

            // Invoke factory processors registered as beans in the context.
            invokeBeanFactoryPostProcessors(beanFactory);

            // Register bean processors that intercept bean creation.
            registerBeanPostProcessors(beanFactory);

            // Initialize message source for this context.
            initMessageSource();

            // Initialize event multicaster for this context.
            // 完成所有的扫描
            initApplicationEventMulticaster();

            // Initialize other special beans in specific context subclasses.
            onRefresh();

            // Check for listener beans and register them.
            registerListeners();

            // Instantiate all remaining (non-lazy-init) singletons.
            // 实例化所有没有延迟的单例类
            finishBeanFactoryInitialization(beanFactory);

            // Last step: publish corresponding event.
            finishRefresh();
        }
    }
}
</code></pre><p>org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</p><pre tabindex=0><code>protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // ....

    // Instantiate all remaining (non-lazy-init) singletons.
    // 实例化所有单例,非lazy
    beanFactory.preInstantiateSingletons();
}
</code></pre><p>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</p><pre tabindex=0><code>@Override
public void preInstantiateSingletons() throws BeansException {
    if (logger.isTraceEnabled()) {
        logger.trace(&#34;Pre-instantiating singletons in &#34; + this);
    }

    // Iterate over a copy to allow for init methods which in turn register new bean definitions.
    // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
    List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);

    // Trigger initialization of all non-lazy singleton beans...
    for (String beanName : beanNames) {
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        // 验证,判断这个是是不是抽象的和是不是单例的和是不是延迟加载的
        if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
            if (isFactoryBean(beanName)) {
                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                if (bean instanceof FactoryBean) {
                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
                    boolean isEagerInit;
                    if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                        isEagerInit = AccessController.doPrivileged(
                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                            getAccessControlContext());
                    }
                    else {
                        isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
                    }
                    if (isEagerInit) {
                        getBean(beanName);
                    }
                }
            }
            else {
                // 验证一切都通过的类,开始实例化普通的bean,还不是spring bean
                getBean(beanName);
            }
        }
    }

    // ....
}
</code></pre><p>org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</p><pre tabindex=0><code>@Override
public Object getBean(String name) throws BeansException {
    return doGetBean(name, null, null, false);
}
</code></pre><p>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</p><p>这里面大部分都是验证,比如depenon,或者import</p><pre tabindex=0><code>protected &lt;T&gt; T doGetBean(
   String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly)
    throws BeansException {

    // 理解bean的名字是否非法
    String beanName = transformedBeanName(name);
    Object bean;

    // Eagerly check singleton cache for manually registered singletons.
    // 这里的方法啊
    Object sharedInstance = getSingleton(beanName);
    if (sharedInstance != null &amp;&amp; args == null) {
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
    }

    else {
        // Fail if we&#39;re already creating this bean instance:
        // We&#39;re assumably within a circular reference.
        // 判断这个类是不是在创建过程中,循环依赖的时候要用
        if (isPrototypeCurrentlyInCreation(beanName)) {
            throw new BeanCurrentlyInCreationException(beanName);
        }

        // Check if bean definition exists in this factory.
        BeanFactory parentBeanFactory = getParentBeanFactory();
        if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
            // 方法注入
            // Not found -&gt; check parent.
            String nameToLookup = originalBeanName(name);
            if (parentBeanFactory instanceof AbstractBeanFactory) {
                return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                    nameToLookup, requiredType, args, typeCheckOnly);
            }
            else if (args != null) {
                // Delegation to parent with explicit args.
                return (T) parentBeanFactory.getBean(nameToLookup, args);
            }
            else if (requiredType != null) {
                // No args -&gt; delegate to standard getBean method.
                return parentBeanFactory.getBean(nameToLookup, requiredType);
            }
            else {
                return (T) parentBeanFactory.getBean(nameToLookup);
            }
        }

        if (!typeCheckOnly) {
            markBeanAsCreated(beanName);
        }

        try {
            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
            checkMergedBeanDefinition(mbd, beanName, args);

            // Guarantee initialization of beans that the current bean depends on.
            String[] dependsOn = mbd.getDependsOn();
            if (dependsOn != null) {
                for (String dep : dependsOn) {
                    if (isDependent(beanName, dep)) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                        &#34;Circular depends-on relationship between &#39;&#34; + beanName + &#34;&#39; and &#39;&#34; + dep + &#34;&#39;&#34;);
                    }
                    registerDependentBean(dep, beanName);
                    try {
                        getBean(dep);
                    }
                    catch (NoSuchBeanDefinitionException ex) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                        &#34;&#39;&#34; + beanName + &#34;&#39; depends on missing bean &#39;&#34; + dep + &#34;&#39;&#34;, ex);
                    }
                }
            }

            // Create bean instance.
            // 判断类是不是单例
            if (mbd.isSingleton()) {
                // getSingleton(String,facotory) 这个方法里有正在创建中的标识设置
                sharedInstance = getSingleton(beanName, () -&gt; {
                    try {
                        // 完成了目标对象的创建
                        // 如果需要代理,还创建了代理
                        return createBean(beanName, mbd, args);
                    }
                    catch (BeansException ex) {
                        // Explicitly remove instance from singleton cache: It might have been put there
                        // eagerly by the creation process, to allow for circular reference resolution.
                        // Also remove any beans that received a temporary reference to the bean.
                        destroySingleton(beanName);
                        throw ex;
                    }
                });
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }

            else if (mbd.isPrototype()) {
                // It&#39;s a prototype -&gt; create a new instance.
                Object prototypeInstance = null;
                try {
                    beforePrototypeCreation(beanName);
                    prototypeInstance = createBean(beanName, mbd, args);
                }
                finally {
                    afterPrototypeCreation(beanName);
                }
                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
            }

            else {
                String scopeName = mbd.getScope();
                if (!StringUtils.hasLength(scopeName)) {
                    throw new IllegalStateException(&#34;No scope name defined for bean ´&#34; + beanName + &#34;&#39;&#34;);
                }
                Scope scope = this.scopes.get(scopeName);
                if (scope == null) {
                    throw new IllegalStateException(&#34;No Scope registered for scope name &#39;&#34; + scopeName + &#34;&#39;&#34;);
                }
                try {
                    Object scopedInstance = scope.get(beanName, () -&gt; {
                        beforePrototypeCreation(beanName);
                        try {
                            return createBean(beanName, mbd, args);
                        }
                        finally {
                            afterPrototypeCreation(beanName);
                        }
                    });
                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                }
                catch (IllegalStateException ex) {
                    throw new BeanCreationException(beanName,
                                                    &#34;Scope &#39;&#34; + scopeName + &#34;&#39; is not active for the current thread; consider &#34; +
                                                    &#34;defining a scoped proxy for this bean if you intend to refer to it from a singleton&#34;,
                                                    ex);
                }
            }
        }
        catch (BeansException ex) {
            cleanupAfterBeanCreationFailure(beanName);
            throw ex;
        }
    }

    // Check if required type matches the type of the actual bean instance.
    if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
        try {
            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
            if (convertedBean == null) {
                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            }
            return convertedBean;
        }
        catch (TypeMismatchException ex) {
            if (logger.isTraceEnabled()) {
                logger.trace(&#34;Failed to convert bean &#39;&#34; + name + &#34;&#39; to required type &#39;&#34; +
                             ClassUtils.getQualifiedName(requiredType) + &#34;&#39;&#34;, ex);
            }
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
        }
    }
    return (T) bean;
}
</code></pre><p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String)</p><pre tabindex=0><code>// 上个代码块第七行调用的
@Override
@Nullable
public Object getSingleton(String beanName) {
    return getSingleton(beanName, true);
}

/** Cache of singleton objects: bean name to bean instance. */
/** 缓存单例对象: bean name to bean instance. */
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);

@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    // 初始化的时候这里肯定是null,但是在初始化完成之后,再调用getBean就肯定不是null
    // isSingletonCurrentlyInCreation 这个方法很重要,说明对象是不是正在创建
    // singletonFactories 也很重要
    Object singletonObject = this.singletonObjects.get(beanName);

    // 判断循环依赖的时候
    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null &amp;&amp; allowEarlyReference) {
                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    singletonObject = singletonFactory.getObject();
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return singletonObject;
}
</code></pre><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean</p><pre tabindex=0><code>@Override
 protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
   throws BeanCreationException {

  if (logger.isTraceEnabled()) {
   logger.trace(&#34;Creating instance of bean &#39;&#34; + beanName + &#34;&#39;&#34;);
  }
  RootBeanDefinition mbdToUse = mbd;

  // Make sure bean class is actually resolved at this point, and
  // clone the bean definition in case of a dynamically resolved Class
  // which cannot be stored in the shared merged bean definition.
        // 从beanDefinition对象中获取出来bean的类型
  Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
  if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
   mbdToUse = new RootBeanDefinition(mbd);
   mbdToUse.setBeanClass(resolvedClass);
  }

  // Prepare method overrides.
  try {
   mbdToUse.prepareMethodOverrides();
  }
  catch (BeanDefinitionValidationException ex) {
   throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
     beanName, &#34;Validation of method overrides failed&#34;, ex);
  }

  try {
   // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
            // 第一次调用个后置处理器
   Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
   if (bean != null) {
    return bean;
   }
  }
  catch (Throwable ex) {
   throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
     &#34;BeanPostProcessor before instantiation of bean failed&#34;, ex);
  }

  try {
            // 调用方法
   Object beanInstance = doCreateBean(beanName, mbdToUse, args);
   if (logger.isTraceEnabled()) {
    logger.trace(&#34;Finished creating instance of bean &#39;&#34; + beanName + &#34;&#39;&#34;);
   }
   return beanInstance;
  }
  catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
   // A previously detected exception with proper bean creation context already,
   // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
   throw ex;
  }
  catch (Throwable ex) {
   throw new BeanCreationException(
     mbdToUse.getResourceDescription(), beanName, &#34;Unexpected exception during bean creation&#34;, ex);
  }
 }
</code></pre><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p><pre tabindex=0><code>protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
   throws BeanCreationException {

    // Instantiate the bean.
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
    if (instanceWrapper == null) {
        // 实例化对象,里面第二次调调用后置处理器
        // 反射调用对象的构造方法
        // 这里java对象就已经有了
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    Object bean = instanceWrapper.getWrappedInstance();
    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
    if (beanType != NullBean.class) {
        mbd.resolvedTargetType = beanType;
    }

    // Allow post-processors to modify the merged bean definition.
    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
                // 第三次调用后置处理器
                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            }

            mbd.postProcessed = true;
        }
    }

    // Eagerly cache singletons to be able to resolve circular references
    // even when triggered by lifecycle interfaces like BeanFactoryAware.
    // 判断是否需要循环依赖
    boolean earlySingletonExposure =
        // 到这里了,也肯定是true
        (mbd.isSingleton() &amp;&amp;
         // 默认值是true
         this.allowCircularReferences &amp;&amp;
  isSingletonCurrentlyInCreation(beanName));

    if (earlySingletonExposure) {
        // 第四次调用后置处理器,判断是否需要AOP
        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
    }

    // Initialize the bean instance.
    Object exposedObject = bean;
    try {
        // 填充属性,也就是我们说的自动注入
        // 里面会完成第五次和第六次后置处理器的调用
        // 看这里
        populateBean(beanName, mbd, instanceWrapper);
        // 初始化spring
        // 里面会进行第七次和第八次后置处理的调用个
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
    catch (Throwable ex) {
        if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
            throw (BeanCreationException) ex;
        }
        else {
            throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, &#34;Initialization of bean failed&#34;, ex);
        }
    }

    if (earlySingletonExposure) {
        Object earlySingletonReference = getSingleton(beanName, false);
        if (earlySingletonReference != null) {
            if (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            }
            else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
                String[] dependentBeans = getDependentBeans(beanName);
                Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
                for (String dependentBean : dependentBeans) {
                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }
                // 省略代码
            }
        }
    }

    // Register bean as disposable.
    try {
        registerDisposableBeanIfNecessary(beanName, bean, mbd);
    }
    catch (BeanDefinitionValidationException ex) {
        throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &#34;Invalid destruction signature&#34;, ex);
    }

    return exposedObject;
}
</code></pre><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance</p><pre tabindex=0><code>protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
    // Make sure bean class is actually resolved at this point.
    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);

    if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                        &#34;Bean class isn&#39;t public, and non-public access not allowed: &#34; + beanClass.getName());
    }

    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
    if (instanceSupplier != null) {
        return obtainFromSupplier(instanceSupplier, beanName);
    }

    if (mbd.getFactoryMethodName() != null) {
        return instantiateUsingFactoryMethod(beanName, mbd, args);
    }

    // Shortcut when re-creating the same bean...
    boolean resolved = false;
    boolean autowireNecessary = false;
    if (args == null) {
        synchronized (mbd.constructorArgumentLock) {
            if (mbd.resolvedConstructorOrFactoryMethod != null) {
                resolved = true;
                autowireNecessary = mbd.constructorArgumentsResolved;
            }
        }
    }
    if (resolved) {
        if (autowireNecessary) {
            return autowireConstructor(beanName, mbd, null, null);
        }
        else {
            return instantiateBean(beanName, mbd);
        }
    }

    // Candidate constructors for autowiring?
    // 第二次调用后置处理器构造方法,通过反射实例化对象,这时候构造方法里有打印,就会打印出日志
    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
        return autowireConstructor(beanName, mbd, ctors, args);
    }

    // Preferred constructors for default construction?
    ctors = mbd.getPreferredConstructors();
    if (ctors != null) {
        return autowireConstructor(beanName, mbd, ctors, null);
    }

    // No special handling: simply use no-arg constructor.
    return instantiateBean(beanName, mbd);
}
</code></pre><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean</p><pre tabindex=0><code>protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
    if (bw == null) {
        if (mbd.hasPropertyValues()) {
            throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, &#34;Cannot apply property values to null instance&#34;);
        }
        else {
            // Skip property population phase for null instance.
            return;
        }
    }

    // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
    // state of the bean before properties are set. This can be used, for example,
    // to support styles of field injection.
    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                    return;
                }
            }
        }
    }

    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

    int resolvedAutowireMode = mbd.getResolvedAutowireMode();
    if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
        // Add property values based on autowire by name if applicable.
        if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
            autowireByName(beanName, mbd, bw, newPvs);
        }
        // Add property values based on autowire by type if applicable.
        if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
            autowireByType(beanName, mbd, bw, newPvs);
        }
        pvs = newPvs;
    }

    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
    boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

    PropertyDescriptor[] filteredPds = null;
    if (hasInstAwareBpps) {
        if (pvs == null) {
            pvs = mbd.getPropertyValues();
        }
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
                // 这里的ibp常用的有两种类型
                // 1.@Resouce 使用的是CommonAnnotationBeanPostProcessor
    // 2.@Autowire 使用的是AutoWireAnnotationBeanPostProcessor
                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                // 这里会调用属性的注入,也就是在这里,碰到循环依赖的时候,就会调用个
                // org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton
                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
                if (pvsToUse == null) {
                    if (filteredPds == null) {
                        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                    }
                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                    if (pvsToUse == null) {
                        return;
                    }
                }
                pvs = pvsToUse;
            }
        }
    }
    if (needsDepCheck) {
        if (filteredPds == null) {
            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
        }
        checkDependencies(beanName, mbd, filteredPds, pvs);
    }

    if (pvs != null) {
        applyPropertyValues(beanName, mbd, bw, pvs);
    }
}
</code></pre><p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory)</p><pre tabindex=0><code>public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
    Assert.notNull(beanName, &#34;Bean name must not be null&#34;);
    synchronized (this.singletonObjects) {
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null) {
            if (this.singletonsCurrentlyInDestruction) {
                throw new BeanCreationNotAllowedException(beanName,
                                                          &#34;Singleton bean creation not allowed while singletons of this factory are in destruction &#34; +
                                                          &#34;(Do not request a bean from a BeanFactory in a destroy method implementation!)&#34;);
            }
            if (logger.isDebugEnabled()) {
                logger.debug(&#34;Creating shared instance of singleton bean &#39;&#34; + beanName + &#34;&#39;&#34;);
            }
            // 重点,如果没有获取到,就设置个标识,表示正在创建
            beforeSingletonCreation(beanName);
            boolean newSingleton = false;
            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
            if (recordSuppressedExceptions) {
                this.suppressedExceptions = new LinkedHashSet&lt;&gt;();
            }
            try {
                singletonObject = singletonFactory.getObject();
                newSingleton = true;
            }
            catch (IllegalStateException ex) {
                // Has the singleton object implicitly appeared in the meantime -&gt;
                // if yes, proceed with it since the exception indicates that state.
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    throw ex;
                }
            }
            catch (BeanCreationException ex) {
                if (recordSuppressedExceptions) {
                    for (Exception suppressedException : this.suppressedExceptions) {
                        ex.addRelatedCause(suppressedException);
                    }
                }
                throw ex;
            }
            finally {
                if (recordSuppressedExceptions) {
                    this.suppressedExceptions = null;
                }
                afterSingletonCreation(beanName);
            }
            if (newSingleton) {
                addSingleton(beanName, singletonObject);
            }
        }
        return singletonObject;
    }
}
</code></pre><p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#beforeSingletonCreation</p><pre tabindex=0><code>/** Names of beans that are currently in creation. */
// 添加到这里来了之后就标识当前这个bean正在创建
private final Set&lt;String&gt; singletonsCurrentlyInCreation =
    Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));

protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
</code></pre><p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory</p><p>二级缓存</p><pre tabindex=0><code>protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
    Assert.notNull(singletonFactory, &#34;Singleton factory must not be null&#34;);
    synchronized (this.singletonObjects) {
        if (!this.singletonObjects.containsKey(beanName)) {
            this.singletonFactories.put(beanName, singletonFactory);
            this.earlySingletonObjects.remove(beanName);
            this.registeredSingletons.add(beanName);
        }
    }
}
</code></pre><h3 id=三个缓存>三个缓存<a href=#三个缓存 class=hanchor arialabel=Anchor>&#8983;</a></h3><pre tabindex=0><code>// singletonObjects：第一级缓存，里面存放的都是创建好的成品Bean。
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object(256);

// earlySingletonObjects : 第二级缓存，里面存放的都是半成品的Bean
private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object(16);

// singletonFactories ：第三级缓存， 不同于前两个存的是 Bean对象引用，此缓存存的bean 工厂对象，也就存的是 专门创建Bean的一个工厂对象。此缓存用于解决循环依赖
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);
</code></pre><h3 id=两个缓存能解决不>两个缓存能解决不<a href=#两个缓存能解决不 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>A引用创建后，提前暴露到<code>半成品缓存中</code></p><p>依赖B，创建B ，B填充属性时发现依赖A， <code>先从成品缓存查找，没有,再从半成品缓存查找</code> 取到A的<code>早期引用</code>。</p><pre tabindex=0><code>B顺利走完创建过程`, 将`B的早期引用从半成品缓存移动到成品缓存
</code></pre><p>B创建完成，A获取到B的引用，继续创建。</p><p>A创建完成，将<code>A的早期引用从半成品缓存移动到成品缓存</code></p><h3 id=为啥需要三个缓存>为啥需要三个缓存<a href=#为啥需要三个缓存 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>上面两个缓存的地方，我们只是没有考虑代理的情况。</p><p>Bean在创建的最后阶段，会检查是否需要创建代理，如果创建了代理，那么最终返回的就是代理实例的引用。我们通过beanname获取到最终是代理实例的引用</p><p>也就是说：假设A最终会创建代理，提前暴露A的引用， B填充属性时填充的是A的原始对象引用。A最终放入成品库里是代理的引用。那么B中依然是A的早期引用。这种结果最终会与我们的期望的大相径庭了。</p><h3 id=完整的流程>完整的流程<a href=#完整的流程 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>关键点：</p><ul><li>A绑定到ObjectFactory 注册到<code>工厂缓存singletonFactory</code>中，</li><li>B在填充A时，<code>先查成品缓存</code>有没有，<code>再查半成品缓存</code>有没有，<code>最后看工厂缓存有没有单例工厂类</code>，有A的ObjectFactory。调用getObject ，执行扩展逻辑，可能返回的代理引用，也可能返回原始引用。</li><li>成功获取到A的早期引用，将A放入到<code>半成品缓存</code>中，B填充A引用完毕。</li><li>代理问题， 循环依赖问题都解决了</li></ul><h1 id=spring-bean-二次开发>Spring Bean 二次开发<a href=#spring-bean-二次开发 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>在实例化Bean之前,Spring会调用扩展的类,实现<code>BeanFactoryPostProcessor</code>,并且机上<code>@component</code>注解,如果没有实现,spring就不会调用</p><h1 id=spring-aop>Spring AOP<a href=#spring-aop class=hanchor arialabel=Anchor>&#8983;</a></h1><h1 id=aop是什么>AOP是什么<a href=#aop是什么 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>AOP的全称是Aspect Orient Programming，即面向切面编程。是对OOP（Object Orient Programming）的一种补充，战门用于处理一些具有横切性质的服务。常常用于日志输出、安全控制等。</p><p>上面说到是对OOP的一种补充，具体补充的是什么呢？考虑一种情况，如果我们需要在所有方法执行前打印一句日志，按照OOP的处理思想，我们需要在每个业务方法开始时加入一些语句，但是我们辛辛苦苦加完之后，如果又要求在这句日志打印后再打印一句，那是不是又要加一遍？这时候你一定会想到，在某个类中编写一个日志打印方法，该方法执行这些日志打印操作，然后在每个业务方法之前加入这句方法调用，这就是面向对象编程思想。但是如果要求我们在业务方法结束时再打印一些日志呢，是不是还要去每个业务方法结束时加一遍？这样始终不是办法，而且我们总是在改业务方法，在业务方法里面掺杂了太多的其他操作，侵入性太高。</p><p>这时候AOP就起到作用了，我们可以编写一个切面类（Aspect），在其中的方法中来编写横切逻辑（如打印日志），然后通过配置或者注解的方式来声明该横切逻辑起作用的位置。</p><h1 id=实现技术>实现技术<a href=#实现技术 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>AOP（这里的AOP指的是面向切面编程思想，而不是Spring AOP）主要的的实现技术主要有Spring AOP和AspectJ。</p><p>1、AspectJ的底层技术。</p><p>AspectJ的底层技术是静态代理，即用一种AspectJ支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。</p><p>2、Spring AOP</p><p>Spring AOP采用的是动态代理，在运行期间对业务方法进行增强，所以不会生成新类，对于动态代理技术，Spring AOP提供了对JDK动态代理的支持以及CGLib的支持。</p><p>JDK动态代理只能为接口创建动态代理实例，而不能对类创建动态代理。需要获得被目标类的接口信息（应用Java的反射技术），生成一个实现了代理接口的动态代理类（字节码），再通过反射机制获得动态代理类的构造函数，利用构造函数生成动态代理类的实例对象，在调用具体方法前调用invokeHandler方法来处理。</p><p>CGLib动态代理需要依赖asm包，把被代理对象类的class文件加载进来，修改其字节码生成子类。</p><p>但是Spring AOP基于注解配置的情况下，需要依赖于AspectJ包的标准注解，但是不需要额外的编译以及AspectJ的织入器，而基于XML配置不需要。</p><h1 id=知识点>知识点<a href=#知识点 class=hanchor arialabel=Anchor>&#8983;</a></h1><h3 id=pointcut>PointCut<a href=#pointcut class=hanchor arialabel=Anchor>&#8983;</a></h3><p>你想要去切某个东西之前总得先知道要在哪里切入是吧，切点格式如下：<code>execution(* com.nuofankj.springdemo.aop.*Service.*(..))</code>格式使用了正常表达式来定义那个范围内的类、那些接口会被当成切点</p><h3 id=advice>Advice<a href=#advice class=hanchor arialabel=Anchor>&#8983;</a></h3><p>通知,所谓的Advice其实就是定义了Aop何时被调用，确实有种通知的感觉</p><ul><li>Before 在方法被调用之前调用</li><li>After 在方法完成之后调用</li><li>After-returning 在方法成功执行之后调用</li><li>After-throwing 在方法抛出异常之后调用</li><li>Around 在被通知的方法调用之前和调用之后调用</li></ul><h3 id=joinpoint>JoinPoint<a href=#joinpoint class=hanchor arialabel=Anchor>&#8983;</a></h3><p>JoinPoint连接点，其实很好理解，上面又有通知、又有切点，那和具体业务的连接点又是什么呢？没错，其实就是对应业务的方法对象，因为我们在横切代码中是有可能需要用到具体方法中的具体数据的，而连接点便可以做到这一点。</p><h3 id=aspect>Aspect<a href=#aspect class=hanchor arialabel=Anchor>&#8983;</a></h3><p>就是我们关注点的模块化。这个关注点可能会横切多个对象和模块，事务管理是横切关注点的很好的例子。它是一个抽象的概念，从软件的角度来说是指在应用程序不同模块中的某一个领域或方面。又pointcut 和advice组成。</p><h3 id=weaving>Weaving<a href=#weaving class=hanchor arialabel=Anchor>&#8983;</a></h3><p>把切面应用到目标对象来创建新的 advised 对象的过程。</p><h1 id=原理>原理<a href=#原理 class=hanchor arialabel=Anchor>&#8983;</a></h1><h3 id=简单说说-aop-的设计>简单说说 AOP 的设计<a href=#简单说说-aop-的设计 class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>每个 Bean 都会被 JDK 或者 Cglib 代理。取决于是否有接口。</li><li>每个 Bean 会有多个“方法拦截器”。注意：拦截器分为两层，外层由 Spring 内核控制流程，内层拦截器是用户设置，也就是 AOP。</li><li>当代理方法被调用时，先经过外层拦截器，外层拦截器根据方法的各种信息判断该方法应该执行哪些“内层拦截器”。内层拦截器的设计就是职责连的设计。</li></ol><h3 id=流程>流程<a href=#流程 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>代理的创建（按步骤）：</p><ul><li>首先，需要创建代理工厂，代理工厂需要 3 个重要的信息：拦截器数组，目标对象接口数组，目标对象。</li><li>创建代理工厂时，默认会在拦截器数组尾部再增加一个默认拦截器 —— 用于最终的调用目标方法。</li><li>当调用 getProxy 方法的时候，会根据接口数量大余 0 条件返回一个代理对象（JDK or Cglib）。</li><li>注意：创建代理对象时，同时会创建一个外层拦截器，这个拦截器就是 Spring 内核的拦截器。用于控制整个 AOP 的流程。</li></ul><p>代理的调用</p><ul><li>当对代理对象进行调用时，就会触发外层拦截器。</li><li>外层拦截器根据代理配置信息，创建内层拦截器链。创建的过程中，会根据表达式判断当前拦截是否匹配这个拦截器。而这个拦截器链设计模式就是职责链模式。</li><li>当整个链条执行到最后时，就会触发创建代理时那个尾部的默认拦截器，从而调用目标方法。最后返回。</li></ul><h1 id=springmcc临时用的>SpringMCC临时用的<a href=#springmcc临时用的 class=hanchor arialabel=Anchor>&#8983;</a></h1><p><a href=https://zhuanlan.zhihu.com/p/62562499>https://zhuanlan.zhihu.com/p/62562499</a></p><h1 id=设置属性>设置属性<a href=#设置属性 class=hanchor arialabel=Anchor>&#8983;</a></h1><pre tabindex=0><code>// 1. 设置属性
// Make web application context available
request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());

// Make locale resolver available
request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);

// Make theme resolver available
request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
</code></pre><h1 id=根据-request-请求的-url-得到对应的-handler-执行链其实就是拦截器和-controller-代理对象>根据 Request 请求的 URL 得到对应的 handler 执行链，其实就是拦截器和 Controller 代理对象<a href=#根据-request-请求的-url-得到对应的-handler-执行链其实就是拦截器和-controller-代理对象 class=hanchor arialabel=Anchor>&#8983;</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 2. 找 handler 返回执行链</span>
</span></span><span style=display:flex><span>HandlerExecutionChain mappedHandler <span style=color:#f92672>=</span> getHandler(request);
</span></span></code></pre></div><h1 id=得到-handler-的适配器>得到 handler 的适配器<a href=#得到-handler-的适配器 class=hanchor arialabel=Anchor>&#8983;</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// This will throw an exception if no adapter is found</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3. 返回 handler 的适配器</span>
</span></span><span style=display:flex><span>HandlerAdapter ha <span style=color:#f92672>=</span> getHandlerAdapter(mappedHandler.<span style=color:#a6e22e>getHandler</span>());
</span></span></code></pre></div><h1 id=循环执行-handler-的-pre-拦截器>循环执行 handler 的 pre 拦截器<a href=#循环执行-handler-的-pre-拦截器 class=hanchor arialabel=Anchor>&#8983;</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 4. 循环执行 handler 的 pre 拦截器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> mappedHandler.<span style=color:#a6e22e>getInterceptors</span>().<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    HandlerInterceptor interceptor <span style=color:#f92672>=</span> mappedHandler.<span style=color:#a6e22e>getInterceptors</span>()<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pre 拦截器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>interceptor.<span style=color:#a6e22e>preHandle</span>(request, response, mappedHandler.<span style=color:#a6e22e>getHandler</span>())) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=执行真正的-handler并返回-modelandviewhandler-是个代理对象可能会执行-aop->执行真正的 handler，并返回 ModelAndView(Handler 是个代理对象，可能会执行 AOP )<a href=#执行真正的-handler并返回-modelandviewhandler-是个代理对象可能会执行-aop- class=hanchor arialabel=Anchor>&#8983;</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 5. 执行真正的 handler，并返回  ModelAndView(Handler 是个代理对象，可能会执行 AOP )</span>
</span></span><span style=display:flex><span>ModelAndView mv <span style=color:#f92672>=</span> ha.<span style=color:#a6e22e>handle</span>(request, response, mappedHandler.<span style=color:#a6e22e>getHandler</span>());
</span></span></code></pre></div><h1 id=循环执行-handler-的-post-拦截器>循环执行 handler 的 post 拦截器<a href=#循环执行-handler-的-post-拦截器 class=hanchor arialabel=Anchor>&#8983;</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 6. 循环执行 handler 的 post 拦截器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> mappedHandler.<span style=color:#a6e22e>getInterceptors</span>().<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1; i <span style=color:#f92672>&gt;=</span>0 ; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>    HandlerInterceptor interceptor <span style=color:#f92672>=</span> mappedHandler.<span style=color:#a6e22e>getInterceptors</span>()<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// post 拦截器</span>
</span></span><span style=display:flex><span>    interceptor.<span style=color:#a6e22e>postHandle</span>(request, response, mappedHandler.<span style=color:#a6e22e>getHandler</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> 根据 ModelAndView 信息得到 View 实例
</span></span><span style=display:flex><span>  View view <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (mv.<span style=color:#a6e22e>isReference</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We need to resolve this view name</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 7. 根据 ModelAndView 信息得到 View 实例</span>
</span></span><span style=display:flex><span>    view <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>viewResolver</span>.<span style=color:#a6e22e>resolveViewName</span>(mv.<span style=color:#a6e22e>getViewName</span>(), locale);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> 渲染 View 返回
</span></span><span style=display:flex><span><span style=color:#75715e>// 8. 渲染 View 返回</span>
</span></span><span style=display:flex><span>view.<span style=color:#a6e22e>render</span>(mv.<span style=color:#a6e22e>getModel</span>(), request, response);
</span></span></code></pre></div><p>其实理解这些才是最重要的。</p><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li><li>HandlerAdapter执行处理器(handler，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View对象</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户</li></ol><h1 id=springboot-启动流程>Springboot 启动流程<a href=#springboot-启动流程 class=hanchor arialabel=Anchor>&#8983;</a></h1><p><a href=https://juejin.im/post/6844903669998026759>https://juejin.im/post/6844903669998026759</a></p><p>通过 <code>SpringFactoriesLoader</code> 加载 <code>META-INF/spring.factories</code> 文件，获取并创建 <code>SpringApplicationRunListener</code> 对象</p><p>然后由 <code>SpringApplicationRunListener</code> 来发出 starting 消息</p><p>创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</p><p>完成之后，依然由 <code>SpringApplicationRunListener</code> 来发出 environmentPrepared 消息</p><p>创建 <code>ApplicationContext</code></p><p>初始化 <code>ApplicationContext</code>，并设置 Environment，加载相关配置等</p><p>由 <code>SpringApplicationRunListener</code> 来发出 <code>contextPrepared</code> 消息，告知SpringBoot 应用使用的 <code>ApplicationContext</code> 已准备OK</p><p>将各种 beans 装载入 <code>ApplicationContext</code>，继续由 <code>SpringApplicationRunListener</code> 来发出 contextLoaded 消息，告知 SpringBoot 应用使用的 <code>ApplicationContext</code> 已装填OK</p><p>refresh ApplicationContext，完成IoC容器可用的最后一步</p><p>由 <code>SpringApplicationRunListener</code> 来发出 started 消息</p><p>完成最终的程序的启动</p><p>由 <code>SpringApplicationRunListener</code> 来发出 running 消息，告知程序已运行起来了</p><h1 id=静态变量注入>静态变量注入<a href=#静态变量注入 class=hanchor arialabel=Anchor>&#8983;</a></h1><pre tabindex=0><code>application.properties中配置下面两个配置项
ccb.ip.address=10.25.177.31
ccb.ip.port=1600
下面问题代码中读取不到application.properties配置文件中的配置
</code></pre><pre tabindex=0><code>@Component
public class BISFrontFileUtil {
    private static Logger logger = LoggerFactory.getLogger(BISFrontFileUtil.class);

    private static String CCBIPADDRESS;

    private static int CCBIPPORT;

    @Value(&#34;${ccb.ip.address}&#34;)
    public void setCCBIPADDRESS(String cCBIPADDRESS) {
        CCBIPADDRESS = cCBIPADDRESS;
    }

    @Value(&#34;${ccb.ip.port}&#34;)
    public void setCCBIPPORT(int cCBIPPORT) {
        CCBIPPORT = cCBIPPORT;
    }
}
</code></pre><p>注意:</p><ol><li>修正代码中的@Component不可丢掉了</li><li>set方法要是非静态的</li></ol><h1 id=springboot的注解>SpringBoot的注解<a href=#springboot的注解 class=hanchor arialabel=Anchor>&#8983;</a></h1><ul><li><a href=https://juejin.cn/post/6844903842476195848#heading-12>@Configuration</a></li></ul><h1 id=configuration><a href=#ZgotmplZ>@Configuration</a><a href=#configuration class=hanchor arialabel=Anchor>&#8983;</a></h1><h3 id=配置并启动spring容器>配置并启动Spring容器<a href=#配置并启动spring容器 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的，作用为：配置spring容器(应用上下文)</p><pre tabindex=0><code>import org.springframework.context.annotation.Configuration;

@Configuration
public class TestConfig {

    public TestConfig(){
        System.out.println(&#34;testconfig collection  init success&#34;);
    }
}
</code></pre><p>相当于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;beans</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans&#34;</span> <span style=color:#a6e22e>xmlns:xsi=</span><span style=color:#e6db74>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xmlns:context=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/context&#34;</span> <span style=color:#a6e22e>xmlns:jdbc=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/jdbc&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xmlns:jee=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/jee&#34;</span> <span style=color:#a6e22e>xmlns:tx=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/tx&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xmlns:util=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/util&#34;</span> <span style=color:#a6e22e>xmlns:task=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/task&#34;</span> <span style=color:#a6e22e>xsi:schemaLocation=</span><span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd&#34;</span> <span style=color:#a6e22e>default-lazy-init=</span><span style=color:#e6db74>&#34;false&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/beans&gt;</span>
</span></span></code></pre></div><p>主方法进行测试:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.context.ApplicationContext;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// @Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext</span>
</span></span><span style=display:flex><span>        ApplicationContext context <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AnnotationConfigApplicationContext(TestConfig.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果加载spring-context.xml文件：</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ApplicationContext context = new</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ClassPathXmlApplicationContext(&#34;spring-context.xml&#34;);</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 结果</span>
</span></span><span style=display:flex><span>WARNING: All illegal access operations will be denied in a future release
</span></span><span style=display:flex><span>testconfig collection  init success
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Process finished with exit code 0
</span></span></code></pre></div><h3 id=configuration启动容器bean注册bean>@Configuration启动容器+@Bean注册Bean<a href=#configuration启动容器bean注册bean class=hanchor arialabel=Anchor>&#8983;</a></h3><p>@Bean标注在方法上(返回某个实例的方法)，等价于spring的xml配置文件中的，作用为：注册bean对象</p><pre tabindex=0><code>@Configuration
public class TestConfig {

    public TestConfig(){
        System.out.println(&#34;testconfig collection  init success&#34;);
    }

    // @Bean注解注册bean,同时可以指定初始化和销毁方法
    // @Bean(name=&#34;testBean&#34;,initMethod=&#34;start&#34;,destroyMethod=&#34;cleanup&#34;)
    //name属性相当于&lt;bean&gt;标签的id
    @Bean
    @Scope(&#34;prototype&#34;)
    public TestBean testBean() {
        return new TestBean();
    }
}

class TestBean {

    private String username;
    private String url;
    private String password;

    public void sayHello() {
        System.out.println(&#34;TestBean sayHello...&#34;);
    }

    public void start() {
        System.out.println(&#34;TestBean init...&#34;);
    }

    public void cleanup() {
        System.out.println(&#34;TestBean destroy...&#34;);
    }
}
</code></pre><p>测试类</p><pre tabindex=0><code>public class Main {

    public static void main(String[] args) {
        // @Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext
        ApplicationContext context = new AnnotationConfigApplicationContext(TestConfig.class);
        System.out.println(context);

        // 如果加载spring-context.xml文件：
        // ApplicationContext context = new
        // ClassPathXmlApplicationContext(&#34;spring-context.xml&#34;);

        //获取bean
        TestBean testBean = (TestBean) context.getBean(&#34;testBean&#34;);
        testBean.sayHello();
    }
}

// 结果
结果：
testconfig collection  init success
TestBean sayHello...
</code></pre><ul><li>@Bean注解在返回实例的方法上，如果未通过@Bean指定bean的名称，则默认与标注的方法名相同（第一个单词转小写）</li><li>@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域</li><li>既然@Bean的作用是注册bean对象，那么完全可以使用@Component、@Controller、@Service、@Ripository等注解注册bean，当然需要配置@ComponentScan注解进行自动扫描</li></ul><p>scope属性1).  singleton属性值（掌握）：默认值，单例2). prototype属性值（掌握）：多例（原型作用域）3). request属性值(了解）：创建对象，把对象放到request域里4). session属性值(了解）：创建对象，把对象放到session域里5). globalSession属性值(了解）：创建对象，把对象放到globalSession域里</p><h3 id=bean下管理bean的生命周期>@Bean下管理bean的生命周期<a href=#bean下管理bean的生命周期 class=hanchor arialabel=Anchor>&#8983;</a></h3><pre tabindex=0><code>// 用上面的例子
//@Bean注解注册bean,同时可以指定初始化和销毁方法
@Bean(name=&#34;testBean&#34;,initMethod=&#34;start&#34;,destroyMethod=&#34;cleanUp&#34;)
@Scope(&#34;prototype&#34;)
public TestBean testBean() {
  return new TestBean();
}
</code></pre><p>测试类</p><pre tabindex=0><code>// 结果
testconfig collection  init success
org.springframework.context.annotation.AnnotationConfigApplicationContext@41975e01, started on Mon Jul 19 09:51:42 PST 2021
TestBean init...
TestBean sayHello...
</code></pre><h3 id=configuration启动容器component注册bean>@Configuration启动容器+@Component注册Bean<a href=#configuration启动容器component注册bean class=hanchor arialabel=Anchor>&#8983;</a></h3><p>bean类</p><pre tabindex=0><code>//添加注册bean的注解
@Component
public class TestBean {

    private String username;
    private String url;
    private String password;

    public void sayHello() {
        System.out.println(&#34;TestBean sayHello...&#34;);
    }

    public void start() {
        System.out.println(&#34;TestBean init...&#34;);
    }

    public void cleanup() {
        System.out.println(&#34;TestBean destroy...&#34;);
    }
}
</code></pre><p>配置类：</p><pre tabindex=0><code>@Configuration
//添加自动扫描注解，basePackages为TestBean包路径
@ComponentScan(basePackages = &#34;com.example.demo.spring2&#34;)
public class TestConfig {

    public TestConfig(){
        System.out.println(&#34;testconfig collection  init success&#34;);
    }

    // @Bean注解注册bean,同时可以指定初始化和销毁方法
//    @Bean(name=&#34;testBean&#34;,initMethod=&#34;start&#34;,destroyMethod=&#34;cleanup&#34;)
////    @Bean
//    @Scope(&#34;prototype&#34;)
//    public TestBean testBean() {
//        return new TestBean();
//    }
}
</code></pre><p>测试类:</p><pre tabindex=0><code>public class Main {

    public static void main(String[] args) {
        // @Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext
        ApplicationContext context = new AnnotationConfigApplicationContext(TestConfig.class);

        // 如果加载spring-context.xml文件：
        // ApplicationContext context = new ClassPathXmlApplicationContext(&#34;spring-context.xml&#34;);

        //获取bean
        TestBean testBean1 = (TestBean) context.getBean(&#34;testBean&#34;);
        testBean1.sayHello();
    }
}

// 结果
testconfig collection  init success
TestBean sayHello...
</code></pre><h3 id=annotationconfigapplicationcontext-注册-appcontext-类的两种方法>AnnotationConfigApplicationContext 注册 AppContext 类的两种方法<a href=#annotationconfigapplicationcontext-注册-appcontext-类的两种方法 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>第一种:</p><pre tabindex=0><code>public static void main(String[] args) {

  // @Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext
  ApplicationContext context = new AnnotationConfigApplicationContext(TestConfig.class);

  //获取bean
  TestBean tb = (TestBean) context.getBean(&#34;testBean&#34;);
  tb.sayHello();
}
</code></pre><p>第二种:</p><pre tabindex=0><code>public class Main {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext();
        annotationConfigApplicationContext.register(TestConfig.class);
        annotationConfigApplicationContext.refresh();
    }
}
</code></pre><h3 id=configuration组合xml>@Configuration组合xml<a href=#configuration组合xml class=hanchor arialabel=Anchor>&#8983;</a></h3><p>配置类</p><pre tabindex=0><code>@Configuration
@ImportResource(&#34;classpath:configtest.xml&#34;)
public class WebConfig {

    public WebConfig(){
        System.out.println(&#34;WebConfig coolection init success&#34;);
    }
}
</code></pre><p>实体类</p><pre tabindex=0><code>public class TestBean2 {

    private String username;
    private String url;
    private String password;

    public void setUsername(String username) {
        this.username = username;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void sayHello() {
        System.out.println(&#34;TestBean2 sayHello...&#34;+username);
    }

    public void start() {
        System.out.println(&#34;TestBean2 init...&#34;);
    }

    public void cleanUp() {
        System.out.println(&#34;TestBean2 destroy...&#34;);
    }
}
</code></pre><p>spring的xml配置文件</p><pre tabindex=0><code>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34;
       xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
       xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt;

    &lt;bean id=&#34;testBean2&#34; class=&#34;com.example.demo.spring3.TestBean2&#34;&gt;
        &lt;property name=&#34;username&#34; value=&#34;ranjun&#34;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>测试类</p><pre tabindex=0><code>public class TestMain2 {

    public static void main(String[] args) {
        // @Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext
        ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);

        // 如果加载spring-context.xml文件：
        // ApplicationContext context = new ClassPathXmlApplicationContext(&#34;spring-context.xml&#34;);

        // 获取bean
        TestBean2 tb = (TestBean2) context.getBean(&#34;testBean2&#34;);
        tb.sayHello();
    }
}

// 结果
WebConfig coolection init success
TestBean2 sayHello...ranjun
</code></pre><h3 id=configuration组合xml和其它注解>@Configuration组合xml和其它注解<a href=#configuration组合xml和其它注解 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>实体类:</p><pre tabindex=0><code>public class TestBean {

    private String username;
    private String url;
    private String password;

    public void sayHello() {
        System.out.println(&#34;TestBean sayHello...&#34;);
    }

    public void start() {
        System.out.println(&#34;TestBean init...&#34;);
    }

    public void cleanup() {
        System.out.println(&#34;TestBean destroy...&#34;);
    }
}

public class TestBean2 {

    private String username;
    private String url;
    private String password;

    public void setUsername(String username) {
        this.username = username;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void sayHello() {
        System.out.println(&#34;TestBean2 sayHello...&#34;+username);
    }

    public void start() {
        System.out.println(&#34;TestBean2 init...&#34;);
    }

    public void cleanUp() {
        System.out.println(&#34;TestBean2 destroy...&#34;);
    }
}
</code></pre><p>配置类</p><pre tabindex=0><code>@Configuration
public class TestConfig {

    public TestConfig(){
        System.out.println(&#34;testconfig collection  init success&#34;);
    }

    @Bean
    @Scope(&#34;prototype&#34;)
    public TestBean testBean() {
        return new TestBean();
    }
}

@Configuration
@ImportResource(&#34;classpath:configtest.xml&#34;)
@Import(TestConfig.class)
public class WebConfig {

    public WebConfig(){
        System.out.println(&#34;WebConfig coolection init success&#34;);
    }
}
</code></pre><p>测试类:</p><pre tabindex=0><code>public class TestMain2 {

    public static void main(String[] args) {
        // @Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext
        ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);

        // 获取bean
        TestBean tb = (TestBean) context.getBean(&#34;testBean&#34;);
        tb.sayHello();

        TestBean2 tb2 = (TestBean2) context.getBean(&#34;testBean2&#34;);
        tb2.sayHello();
    }
}

// 结果
WebConfig coolection init success
testconfig collection  init success
TestBean sayHello...
TestBean2 sayHello...ranjun
</code></pre></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=../../posts/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/><span class=button__icon>←</span>
<span class=button__text>代码片段</span>
</a></span><span class="button next"><a href=../../posts/%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/><span class=button__text>面试记录</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=../../bundle.min.js></script></div></body></html>