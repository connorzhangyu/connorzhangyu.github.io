<!doctype html><html lang=zh><head><title>springMVC :: Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Spring MVC 说一下 spring mvc 运行流程？ Spring MVC运行流程图：
Spring运行流程描述：
用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获； DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(&mldr;)方法） 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：
HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息
数据转换：对请求消息进行数据转换。如String转换成Integer、Double等
数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等
数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； ViewResolver 结合Model和View，来渲染视图； 将渲染结果返回给客户端。 spring mvc 有哪些组件？ Spring MVC的核心组件：
DispatcherServlet：中央控制器，把请求给转发到具体的控制类
Controller：具体处理请求的控制器
HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略
ModelAndView：服务层返回的数据和视图层的封装类
ViewResolver：视图解析器，解析具体的视图
Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作
@Controller和@RestController的区别? Controller, RestController的共同点 都是用来表示Spring某个类的是否可以接收HTTP请求
Controller, RestController的不同点
@Controller标识一个Spring类是Spring MVC controller处理器
@RestController：@RestController是@Controller和@ResponseBody的结合体，两个标注合并起来的作用。
3、如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。
例如：本来应该到success.jsp页面的，则其显示success.
4、如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。
5、如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。
@RequestBody @ResponseBody 的作用 @RequestBody 作用： 该注解用于读取 Request 请求的 body 部分数据，使用系统默认配置的 HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上； 再把 HttpMessageConverter 返回的对象数据绑定到 controller 中方法的参数上。 使用时机： GET、POST方式提交时， 根据 request header Content-Type 的值来判断: application/x-www-form-urlencoded：可选（即非必须，因为这种情况的数据 @RequestParam, @ModelAttribute 也可以处理，当然@RequestBody也能处理）； multipart/form-data：不能处理（即使用@RequestBody不能处理这种格式的数据）； 其他格式：必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）； PUT 方式提交时， 根据request header Content-Type的值来判断: application/x-www-form-urlencoded：必须； multipart/form-data：不能处理； 其他格式：必须； 作者：希希里之海 链接：https://www.jianshu.com/p/64b22da6c9ab 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=../../posts/springmvc/><link rel=stylesheet href=../../styles.css><link rel="shortcut icon" href=../../img/theme-colors/orange.png><link rel=apple-touch-icon href=../../img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Connor"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="og:title" content="springMVC"><meta property="og:description" content="Spring MVC 说一下 spring mvc 运行流程？ Spring MVC运行流程图：
Spring运行流程描述：
用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获； DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(&mldr;)方法） 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：
HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息
数据转换：对请求消息进行数据转换。如String转换成Integer、Double等
数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等
数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； ViewResolver 结合Model和View，来渲染视图； 将渲染结果返回给客户端。 spring mvc 有哪些组件？ Spring MVC的核心组件：
DispatcherServlet：中央控制器，把请求给转发到具体的控制类
Controller：具体处理请求的控制器
HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略
ModelAndView：服务层返回的数据和视图层的封装类
ViewResolver：视图解析器，解析具体的视图
Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作
@Controller和@RestController的区别? Controller, RestController的共同点 都是用来表示Spring某个类的是否可以接收HTTP请求
Controller, RestController的不同点
@Controller标识一个Spring类是Spring MVC controller处理器
@RestController：@RestController是@Controller和@ResponseBody的结合体，两个标注合并起来的作用。
3、如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。
例如：本来应该到success.jsp页面的，则其显示success.
4、如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。
5、如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。
@RequestBody @ResponseBody 的作用 @RequestBody 作用： 该注解用于读取 Request 请求的 body 部分数据，使用系统默认配置的 HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上； 再把 HttpMessageConverter 返回的对象数据绑定到 controller 中方法的参数上。 使用时机： GET、POST方式提交时， 根据 request header Content-Type 的值来判断: application/x-www-form-urlencoded：可选（即非必须，因为这种情况的数据 @RequestParam, @ModelAttribute 也可以处理，当然@RequestBody也能处理）； multipart/form-data：不能处理（即使用@RequestBody不能处理这种格式的数据）； 其他格式：必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）； PUT 方式提交时， 根据request header Content-Type的值来判断: application/x-www-form-urlencoded：必须； multipart/form-data：不能处理； 其他格式：必须； 作者：希希里之海 链接：https://www.jianshu.com/p/64b22da6c9ab 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
"><meta property="og:url" content="/posts/springmvc/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="/"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-01-04 04:08:56 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=../../><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=../../posts/springmvc/>springMVC</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><div><h1 id=spring-mvc>Spring MVC<a href=#spring-mvc class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=说一下-spring-mvc-运行流程>说一下 spring mvc 运行流程？<a href=#说一下-spring-mvc-运行流程 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Spring MVC运行流程图：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/d1f3cfcfacc0c82aa4f6870eaca54d649c6b8358aaff78b9ffa1413397124e3f1c0ec0ad425d6fe651ce7a7e1ee52520?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=495869333&amp;fname=springMVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png&amp;size=750" alt="Spring MVC运行流程图"></p><p>Spring运行流程描述：</p><ol><li>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</li><li>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</li><li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(&mldr;)方法）</li><li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：<br>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息<br>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等<br>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等<br>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li><li>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</li><li>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</li><li>ViewResolver 结合Model和View，来渲染视图；</li><li>将渲染结果返回给客户端。</li></ol><h2 id=spring-mvc-有哪些组件>spring mvc 有哪些组件？<a href=#spring-mvc-有哪些组件 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Spring MVC的核心组件：<br>DispatcherServlet：中央控制器，把请求给转发到具体的控制类<br>Controller：具体处理请求的控制器<br>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略<br>ModelAndView：服务层返回的数据和视图层的封装类<br>ViewResolver：视图解析器，解析具体的视图<br>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</p><h2 id=controller和restcontroller的区别>@Controller和@RestController的区别?<a href=#controller和restcontroller的区别 class=hanchor arialabel=Anchor>&#8983;</a></h2><ol><li><p>Controller, RestController的共同点
都是用来表示Spring某个类的是否可以接收HTTP请求</p></li><li><p>Controller, RestController的不同点<br>@Controller标识一个Spring类是Spring MVC controller处理器<br>@RestController：@RestController是@Controller和@ResponseBody的结合体，两个标注合并起来的作用。</p></li></ol><p>3、如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。<br>例如：本来应该到success.jsp页面的，则其显示success.</p><p>4、如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。</p><p>5、如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。</p><h2 id=requestbody-responsebody-的作用>@RequestBody @ResponseBody 的作用<a href=#requestbody-responsebody-的作用 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=requestbody>@RequestBody<a href=#requestbody class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>作用：
该注解用于读取 Request 请求的 body 部分数据，使用系统默认配置的 HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上；
再把 HttpMessageConverter 返回的对象数据绑定到 controller 中方法的参数上。</li><li>使用时机：
GET、POST方式提交时， 根据 request header Content-Type 的值来判断:
application/x-www-form-urlencoded：可选（即非必须，因为这种情况的数据 @RequestParam, @ModelAttribute 也可以处理，当然@RequestBody也能处理）；
multipart/form-data：不能处理（即使用@RequestBody不能处理这种格式的数据）；
其他格式：必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；
PUT 方式提交时， 根据request header Content-Type的值来判断:
application/x-www-form-urlencoded：必须；
multipart/form-data：不能处理；
其他格式：必须；</li></ol><p>作者：希希里之海
链接：https://www.jianshu.com/p/64b22da6c9ab
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id=responsebody>@ResponseBody<a href=#responsebody class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li><p>作用：
该注解用于将 Controller 的方法返回的对象，通过适当的 HttpMessageConverter 转换为指定格式后，写入到 Response 对象的body 数据区。</p></li><li><p>使用时机：
返回的数据不是 html 标签的页面，而是其他某种格式的数据时（如 json、xml 等）使用。</p></li></ol><p>作者：希希里之海
链接：https://www.jianshu.com/p/64b22da6c9ab
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id=requestmapping-的作用是什么>@RequestMapping 的作用是什么？<a href=#requestmapping-的作用是什么 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明。</p><p>value， method：<br>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；<br>method：指定请求的method类型， GET、POST、PUT、DELETE等；</p><p>consumes，produces<br>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；<br>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p>params，headers<br>params： 指定request中必须包含某些参数值是，才让该方法处理。<br>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><h2 id=autowired-的作用是什么>@Autowired 的作用是什么？<a href=#autowired-的作用是什么 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>《@Autowired用法详解》：blog.csdn.net/u013257679/article/details/52295106</p><p>首先要知道另一个东西，default-autowire，它是在xml文件中进行配置的，可以设置为byName、byType、constructor和autodetect；比如byName，不用显式的在bean中写出依赖的对象，它会自动的匹配其它bean中id名与本bean的set**相同的，并自动装载。</p><p>@Autowired是用在JavaBean中的注解，通过byType形式，用来给指定的字段或方法注入所需的外部资源。
两者的功能是一样的，就是能减少或者消除属性或构造器参数的设置，只是配置地方不一样而已。
autowire四种模式的区别：</p><table><thead><tr><th style=text-align:center>模式</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td style=text-align:center>no</td><td style=text-align:center></td></tr><tr><td style=text-align:center>byName</td><td style=text-align:center>根据属性名自动装配。此选项将检查容器并根据名字查找与属性完全一致的bean, 并将其与属性自动装配。例如，再bean中将autowire设置为 by name, 而该 bean 包含 master 属性（同时提供setMaster(..)方法），Spring 就会查找名为 master 的 bean 定义，并且用它来装配给master属性</td></tr><tr><td style=text-align:center>byType</td><td style=text-align:center>如果容器中存在一个与制定属性类型相同的 bean,那么将与该属性自动装配。入股哦存在多个该类型的 bean，那么将会抛出异常，并指出不能使用 byType 方式进行自动装配。若没有找到相匹配的 bean，则什么事都不发生，属性也不会被设置。如果你不希望这样，那么可以通过设置 dependency-check=&ldquo;object&rdquo; 让Spring 抛出异常</td></tr><tr><td style=text-align:center>constructor</td><td style=text-align:center>与 byType 的方式类似，不同指出在于它应用于构造器参数。如果在容器中没有找到与构造器参数类型一直的 bean，那么将会抛出异常</td></tr><tr><td style=text-align:center>autodetect</td><td style=text-align:center>通过 bean 类的自省机制(introspection)来决定是使用 constructor 还是 byType 方式进行自动装配。如果发现默认的构造器，那么将使用 byType 方式</td></tr></tbody></table><p>先看一下bean实例化和@Autowired装配过程：
一切都是从bean工厂的getBean方法开始的，一旦该方法调用总会返回一个bean实例，无论当前是否存在，不存在就实例化一个并装配，否则直接返回。（Spring MVC是在什么时候开始执行bean的实例化过程的呢？其实就在组件扫描完成之后）</p><p>实例化和装配过程中会多次递归调用getBean方法来解决类之间的依赖。</p><p>Spring几乎考虑了所有可能性，所以方法特别复杂但完整有条理。</p><p>@Autowired最终是根据类型来查找和装配元素的，但是我们设置了&lt;beans default-autowire=&ldquo;byName&rdquo;/>后会影响最终的类型匹配查找。因为在前面有根据BeanDefinition的autowire类型设置PropertyValue值得一步，其中会有新实例的创建和注册。就是那个autowireByName方法。</p><p>下面通过@Autowired来说明一下用法</p><p>Setter 方法中的 @Autowired
你可以在 JavaBean中的 setter 方法中使用 @Autowired 注解。当 Spring遇到一个在 setter 方法中使用的 @Autowired 注解，它会在方法中执行 byType 自动装配。
这里是 TextEditor.java 文件的内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.tutorialspoint;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.beans.factory.annotation.Autowired;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TextEditor</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> SpellChecker spellChecker;
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setSpellChecker</span>( SpellChecker spellChecker ){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>spellChecker</span> <span style=color:#f92672>=</span> spellChecker;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> SpellChecker <span style=color:#a6e22e>getSpellChecker</span>( ) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> spellChecker;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>spellCheck</span>() {
</span></span><span style=display:flex><span>      spellChecker.<span style=color:#a6e22e>checkSpelling</span>();
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面是另一个依赖的类文件 SpellChecker.java 的内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.tutorialspoint;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SpellChecker</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SpellChecker</span>(){
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Inside SpellChecker constructor.&#34;</span> );
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkSpelling</span>(){
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Inside checkSpelling.&#34;</span> );
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面是 MainApp.java 文件的内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.tutorialspoint;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.context.ApplicationContext;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainApp</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>      ApplicationContext context <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ClassPathXmlApplicationContext(<span style=color:#e6db74>&#34;Beans.xml&#34;</span>);
</span></span><span style=display:flex><span>      TextEditor te <span style=color:#f92672>=</span> (TextEditor) context.<span style=color:#a6e22e>getBean</span>(<span style=color:#e6db74>&#34;textEditor&#34;</span>);
</span></span><span style=display:flex><span>      te.<span style=color:#a6e22e>spellCheck</span>();
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面是配置文件 Beans.xml：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;beans</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xmlns:xsi=</span><span style=color:#e6db74>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xmlns:context=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/context&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xsi:schemaLocation=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    http://www.springframework.org/schema/context
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    http://www.springframework.org/schema/context/spring-context-3.0.xsd&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;context:annotation-config/&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>&lt;!-- Definition for textEditor bean without constructor-arg  --&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;textEditor&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;com.tutorialspoint.TextEditor&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;/bean&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>&lt;!-- Definition for spellChecker bean --&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;spellChecker&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;com.tutorialspoint.SpellChecker&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;/bean&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/beans&gt;</span>
</span></span></code></pre></div><p>一旦你已经完成的创建了源文件和 bean 配置文件，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：</p><pre><code>Inside SpellChecker constructor.
Inside checkSpelling.
</code></pre><p>属性中的 @Autowired
你可以在属性中使用 @Autowired 注解来除去 setter 方法。当时使用 为自动连接属性传递的时候，Spring 会将这些传递过来的值或者引用自动分配给那些属性。所以利用在属性中 @Autowired 的用法，你的 TextEditor.java 文件将变成如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.tutorialspoint;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.beans.factory.annotation.Autowired;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TextEditor</span> {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> SpellChecker spellChecker;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>TextEditor</span>() {
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Inside TextEditor constructor.&#34;</span> );
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> SpellChecker <span style=color:#a6e22e>getSpellChecker</span>( ){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> spellChecker;
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>spellCheck</span>(){
</span></span><span style=display:flex><span>      spellChecker.<span style=color:#a6e22e>checkSpelling</span>();
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面是配置文件 Beans.xml：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;beans</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xmlns:xsi=</span><span style=color:#e6db74>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xmlns:context=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/context&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xsi:schemaLocation=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    http://www.springframework.org/schema/context
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    http://www.springframework.org/schema/context/spring-context-3.0.xsd&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;context:annotation-config/&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>&lt;!-- Definition for textEditor bean --&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;textEditor&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;com.tutorialspoint.TextEditor&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;/bean&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>&lt;!-- Definition for spellChecker bean --&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;spellChecker&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;com.tutorialspoint.SpellChecker&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;/bean&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/beans&gt;</span>
</span></span></code></pre></div><p>一旦你在源文件和 bean 配置文件中完成了上面两处改变，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：</p><pre><code>Inside TextEditor constructor.
Inside SpellChecker constructor.
Inside checkSpelling.
</code></pre><p>构造函数中的 @Autowired
你也可以在构造函数中使用 @Autowired。一个构造函数 @Autowired 说明当创建 bean 时，即使在 XML 文件中没有使用 元素配置 bean ，构造函数也会被自动连接。让我们检查一下下面的示例。
这里是 TextEditor.java 文件的内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.tutorialspoint;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.beans.factory.annotation.Autowired;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TextEditor</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> SpellChecker spellChecker;
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>TextEditor</span>(SpellChecker spellChecker){
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Inside TextEditor constructor.&#34;</span> );
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>spellChecker</span> <span style=color:#f92672>=</span> spellChecker;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>spellCheck</span>(){
</span></span><span style=display:flex><span>      spellChecker.<span style=color:#a6e22e>checkSpelling</span>();
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面是配置文件 Beans.xml：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;beans</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xmlns:xsi=</span><span style=color:#e6db74>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xmlns:context=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/context&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xsi:schemaLocation=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    http://www.springframework.org/schema/context
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    http://www.springframework.org/schema/context/spring-context-3.0.xsd&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;context:annotation-config/&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>&lt;!-- Definition for textEditor bean without constructor-arg  --&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;textEditor&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;com.tutorialspoint.TextEditor&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;/bean&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>&lt;!-- Definition for spellChecker bean --&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;spellChecker&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;com.tutorialspoint.SpellChecker&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>&lt;/bean&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/beans&gt;</span>
</span></span></code></pre></div><p>一旦你在源文件和 bean 配置文件中完成了上面两处改变，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：</p><pre><code>Inside TextEditor constructor.
Inside SpellChecker constructor.
Inside checkSpelling.
</code></pre><p>@Autowired 的（required=false）选项<br>默认情况下，@Autowired 注解意味着依赖是必须的，它类似于 @Required 注解，然而，你可以使用 @Autowired 的 （required=false） 选项关闭默认行为。<br>即使你不为 age 属性传递任何参数，下面的示例也会成功运行，但是对于 name 属性则需要一个参数。你可以自己尝试一下这个示例，因为除了只有 Student.java 文件被修改以外，它和 @Required 注解示例是相似的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.tutorialspoint;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.beans.factory.annotation.Autowired;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> Integer age;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Autowired</span>(required<span style=color:#f92672>=</span><span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span>(Integer age) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> Integer <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> age;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>   }   
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> name;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>————————————————
版权声明：本文为CSDN博主「阿文施瓦辛格」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u013257679/article/details/52295106</p><h2 id=目录>目录<a href=#目录 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><a href=../../java/javaBase.md>Java基础</a></li><li><a href=../../java/collection.md>容器</a></li><li><a href=../../java/thread.md>线程</a></li><li><a href=../../java/reflection.md>反射</a></li><li><a href=../../java/cloneable.md>对象克隆</a></li><li><a href=../../java/javaWeb.md>JavaWeb</a></li><li><a href=../../java/exception.md>异常</a></li><li><a href=../../java/netWork.md>网络服务</a></li><li><a href=../../java/designpattern.md>设计模式</a></li><li><a href=../../java/spring.md>Spring</a></li><li><a href=../../java/springMVC.md>Spring MVC</a></li><li><a href=../../java/springBoot.md>Spring Boot</a></li><li><a href=../../java/springCloud.md>Spring Cloud</a></li><li><a href=../../java/hibernate.md>Hibernate</a></li><li><a href=../../java/mybatis.md>Mybatis</a></li><li><a href=../../java/mq.md>队列</a></li><li><a href=../../java/zookeeper.md>Zookeeper</a></li><li><a href=../../java/mySql.md>MySql</a></li><li><a href=../../java/redis.md>Redis</a></li><li><a href=../../java/jvm.md>Jvm</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=../../posts/reflection/><span class=button__icon>←</span>
<span class=button__text>reflection</span>
</a></span><span class="button next"><a href=../../posts/thread/><span class=button__text>thread</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=../../bundle.min.js></script></div></body></html>