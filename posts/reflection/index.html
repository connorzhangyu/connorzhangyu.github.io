<!doctype html><html lang=zh><head><title>reflection :: Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="反射 什么是反射？ 反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力
Java反射：
在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法
Java反射机制主要提供了以下功能：
在运行时判断任意一个对象所属的类。
在运行时构造任意一个类的对象。
在运行时判断任意一个类所具有的成员变量和方法。
在运行时调用任意一个对象的方法。
什么是 java 序列化？什么情况下需要序列化？ 简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。
什么情况下需要序列化：
当你想把的内存中的对象状态保存到一个文件中或者数据库中时候； 当你想用套接字在网络上传送对象的时候； 当你想通过RMI传输对象的时候； 动态代理是什么？有哪些应用？ 动态代理：
当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。
动态代理的应用：
Spring的AOP
加事务
加权限
加日志
怎么实现动态代理？ 首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。
目录 Java基础 容器 线程 反射 对象克隆 JavaWeb 异常 网络服务 设计模式 Spring Spring MVC Spring Boot Spring Cloud Hibernate Mybatis 队列 Zookeeper MySql Redis Jvm "><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://connorzhangyu.com/posts/reflection/><link rel=stylesheet href=https://connorzhangyu.com/styles.css><link rel="shortcut icon" href=https://connorzhangyu.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://connorzhangyu.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Connor"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="og:title" content="reflection"><meta property="og:description" content="反射 什么是反射？ 反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力
Java反射：
在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法
Java反射机制主要提供了以下功能：
在运行时判断任意一个对象所属的类。
在运行时构造任意一个类的对象。
在运行时判断任意一个类所具有的成员变量和方法。
在运行时调用任意一个对象的方法。
什么是 java 序列化？什么情况下需要序列化？ 简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。
什么情况下需要序列化：
当你想把的内存中的对象状态保存到一个文件中或者数据库中时候； 当你想用套接字在网络上传送对象的时候； 当你想通过RMI传输对象的时候； 动态代理是什么？有哪些应用？ 动态代理：
当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。
动态代理的应用：
Spring的AOP
加事务
加权限
加日志
怎么实现动态代理？ 首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。
目录 Java基础 容器 线程 反射 对象克隆 JavaWeb 异常 网络服务 设计模式 Spring Spring MVC Spring Boot Spring Cloud Hibernate Mybatis 队列 Zookeeper MySql Redis Jvm "><meta property="og:url" content="https://connorzhangyu.com/posts/reflection/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="https://connorzhangyu.com/"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-01-04 04:08:56 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://connorzhangyu.com/posts/reflection/>reflection</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><div><h1 id=反射>反射<a href=#反射 class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=什么是反射>什么是反射？<a href=#什么是反射 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力<br>Java反射：<br>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法<br>Java反射机制主要提供了以下功能：<br>在运行时判断任意一个对象所属的类。<br>在运行时构造任意一个类的对象。<br>在运行时判断任意一个类所具有的成员变量和方法。<br>在运行时调用任意一个对象的方法。</p><h2 id=什么是-java-序列化什么情况下需要序列化>什么是 java 序列化？什么情况下需要序列化？<a href=#什么是-java-序列化什么情况下需要序列化 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。<br>什么情况下需要序列化：</p><ol><li>当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>当你想用套接字在网络上传送对象的时候；</li><li>当你想通过RMI传输对象的时候；</li></ol><h2 id=动态代理是什么有哪些应用>动态代理是什么？有哪些应用？<a href=#动态代理是什么有哪些应用 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>动态代理：<br>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。<br>动态代理的应用：<br>Spring的AOP<br>加事务<br>加权限<br>加日志</p><h2 id=怎么实现动态代理>怎么实现动态代理？<a href=#怎么实现动态代理 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p><h2 id=目录>目录<a href=#目录 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><a href=/java/javaBase.md>Java基础</a></li><li><a href=/java/collection.md>容器</a></li><li><a href=/java/thread.md>线程</a></li><li><a href=/java/reflection.md>反射</a></li><li><a href=/java/cloneable.md>对象克隆</a></li><li><a href=/java/javaWeb.md>JavaWeb</a></li><li><a href=/java/exception.md>异常</a></li><li><a href=/java/netWork.md>网络服务</a></li><li><a href=/java/designpattern.md>设计模式</a></li><li><a href=/java/spring.md>Spring</a></li><li><a href=/java/springMVC.md>Spring MVC</a></li><li><a href=/java/springBoot.md>Spring Boot</a></li><li><a href=/java/springCloud.md>Spring Cloud</a></li><li><a href=/java/hibernate.md>Hibernate</a></li><li><a href=/java/mybatis.md>Mybatis</a></li><li><a href=/java/mq.md>队列</a></li><li><a href=/java/zookeeper.md>Zookeeper</a></li><li><a href=/java/mySql.md>MySql</a></li><li><a href=/java/redis.md>Redis</a></li><li><a href=/java/jvm.md>Jvm</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://connorzhangyu.com/posts/network/><span class=button__icon>←</span>
<span class=button__text>netWork</span>
</a></span><span class="button next"><a href=https://connorzhangyu.com/posts/springmvc/><span class=button__text>springMVC</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>