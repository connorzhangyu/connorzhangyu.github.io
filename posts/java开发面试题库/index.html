<!doctype html><html lang=zh><head><title>Java开发面试题库 :: Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Java 面试题库（完整版，含标准答案） 模块一：Java 基础（共 10 题） 1. Java 的基本数据类型有哪些？ Java 有 8 种基本数据类型：byte、short、int、long、float、double、char、boolean。
2. 面向对象的三大特性是什么？ 封装、继承、多态。
3. String 为什么是不可变的？ 因为 String 被 final 修饰，底层使用 char 数组存储，一旦创建不可更改，提高安全性和效率（如在 HashMap 中）。
4. ArrayList 和 LinkedList 的区别？ ArrayList：基于数组，查找快，插入删除慢。 LinkedList：基于链表，插入删除快，查找慢。 5. 重载和重写的区别？ 重载（Overload）：同一类中方法名相同，参数不同。 重写（Override）：子类重写父类方法，参数和返回值相同。 6. 抽象类和接口的区别？ 抽象类可以包含实现的方法，接口只能包含抽象方法（Java 8 以后允许 default 方法）。 一个类只能继承一个抽象类，但可以实现多个接口。 7. Java 中的异常体系？ Checked Exception（受检异常）：如 IOException。 Unchecked Exception（运行时异常）：如 NullPointerException。 8. final、finally 和 finalize 的区别？ final：修饰不可变内容。 finally：异常处理中始终执行的代码块。 finalize：垃圾回收前调用的方法（不推荐使用）。 9. Java 中的包装类有哪些？ Boolean、Byte、Character、Short、Integer、Long、Float、Double。
10. Java 如何实现反射？ 通过 Class.forName()、getDeclaredMethods()、getConstructor() 等方法反射获取类信息并动态操作。
"><meta name=keywords content=","><meta name=robots content="noodp"><link rel=canonical href=https://connorzhangyu.com/posts/java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/><link rel=stylesheet href=https://connorzhangyu.com/styles.css><link rel="shortcut icon" href=https://connorzhangyu.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://connorzhangyu.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Connor"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="og:title" content="Java开发面试题库"><meta property="og:description" content="Java 面试题库（完整版，含标准答案） 模块一：Java 基础（共 10 题） 1. Java 的基本数据类型有哪些？ Java 有 8 种基本数据类型：byte、short、int、long、float、double、char、boolean。
2. 面向对象的三大特性是什么？ 封装、继承、多态。
3. String 为什么是不可变的？ 因为 String 被 final 修饰，底层使用 char 数组存储，一旦创建不可更改，提高安全性和效率（如在 HashMap 中）。
4. ArrayList 和 LinkedList 的区别？ ArrayList：基于数组，查找快，插入删除慢。 LinkedList：基于链表，插入删除快，查找慢。 5. 重载和重写的区别？ 重载（Overload）：同一类中方法名相同，参数不同。 重写（Override）：子类重写父类方法，参数和返回值相同。 6. 抽象类和接口的区别？ 抽象类可以包含实现的方法，接口只能包含抽象方法（Java 8 以后允许 default 方法）。 一个类只能继承一个抽象类，但可以实现多个接口。 7. Java 中的异常体系？ Checked Exception（受检异常）：如 IOException。 Unchecked Exception（运行时异常）：如 NullPointerException。 8. final、finally 和 finalize 的区别？ final：修饰不可变内容。 finally：异常处理中始终执行的代码块。 finalize：垃圾回收前调用的方法（不推荐使用）。 9. Java 中的包装类有哪些？ Boolean、Byte、Character、Short、Integer、Long、Float、Double。
10. Java 如何实现反射？ 通过 Class.forName()、getDeclaredMethods()、getConstructor() 等方法反射获取类信息并动态操作。
"><meta property="og:url" content="https://connorzhangyu.com/posts/java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="https://connorzhangyu.com/"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-07-31 01:16:47 +0700 +0700"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://connorzhangyu.com/posts/java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/>Java开发面试题库</a></h1><div class=post-meta><time class=post-date>2025-07-31</time><span class=post-author>Connor</span></div><span class=post-tags>#<a href=https://connorzhangyu.com/tags/></a>&nbsp;
#<a href=https://connorzhangyu.com/tags/></a>&nbsp;</span><div class=post-content><div><h1 id=java-面试题库完整版含标准答案>Java 面试题库（完整版，含标准答案）<a href=#java-面试题库完整版含标准答案 class=hanchor arialabel=Anchor>&#8983;</a></h1><hr><h2 id=模块一java-基础共-10-题>模块一：Java 基础（共 10 题）<a href=#模块一java-基础共-10-题 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=1-java-的基本数据类型有哪些>1. Java 的基本数据类型有哪些？<a href=#1-java-的基本数据类型有哪些 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Java 有 8 种基本数据类型：byte、short、int、long、float、double、char、boolean。</p><h3 id=2-面向对象的三大特性是什么>2. 面向对象的三大特性是什么？<a href=#2-面向对象的三大特性是什么 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>封装、继承、多态。</p><h3 id=3-string-为什么是不可变的>3. String 为什么是不可变的？<a href=#3-string-为什么是不可变的 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>因为 String 被 final 修饰，底层使用 char 数组存储，一旦创建不可更改，提高安全性和效率（如在 HashMap 中）。</p><h3 id=4-arraylist-和-linkedlist-的区别>4. ArrayList 和 LinkedList 的区别？<a href=#4-arraylist-和-linkedlist-的区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>ArrayList：基于数组，查找快，插入删除慢。</li><li>LinkedList：基于链表，插入删除快，查找慢。</li></ul><h3 id=5-重载和重写的区别>5. 重载和重写的区别？<a href=#5-重载和重写的区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>重载（Overload）：同一类中方法名相同，参数不同。</li><li>重写（Override）：子类重写父类方法，参数和返回值相同。</li></ul><h3 id=6-抽象类和接口的区别>6. 抽象类和接口的区别？<a href=#6-抽象类和接口的区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>抽象类可以包含实现的方法，接口只能包含抽象方法（Java 8 以后允许 default 方法）。</li><li>一个类只能继承一个抽象类，但可以实现多个接口。</li></ul><h3 id=7-java-中的异常体系>7. Java 中的异常体系？<a href=#7-java-中的异常体系 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Checked Exception（受检异常）：如 IOException。</li><li>Unchecked Exception（运行时异常）：如 NullPointerException。</li></ul><h3 id=8-finalfinally-和-finalize-的区别>8. final、finally 和 finalize 的区别？<a href=#8-finalfinally-和-finalize-的区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>final：修饰不可变内容。</li><li>finally：异常处理中始终执行的代码块。</li><li>finalize：垃圾回收前调用的方法（不推荐使用）。</li></ul><h3 id=9-java-中的包装类有哪些>9. Java 中的包装类有哪些？<a href=#9-java-中的包装类有哪些 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Boolean、Byte、Character、Short、Integer、Long、Float、Double。</p><h3 id=10-java-如何实现反射>10. Java 如何实现反射？<a href=#10-java-如何实现反射 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>通过 <code>Class.forName()</code>、<code>getDeclaredMethods()</code>、<code>getConstructor()</code> 等方法反射获取类信息并动态操作。</p><hr><h2 id=模块二jvm-与性能优化共-10-题>模块二：JVM 与性能优化（共 10 题）<a href=#模块二jvm-与性能优化共-10-题 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=1-jvm-内存模型>1. JVM 内存模型？<a href=#1-jvm-内存模型 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>程序计数器、虚拟机栈、本地方法栈、堆、方法区。</p><h3 id=2-什么是类加载器>2. 什么是类加载器？<a href=#2-什么是类加载器 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>BootstrapClassLoader、ExtensionClassLoader、AppClassLoader，遵循双亲委派模型。</p><h3 id=3-jvm-垃圾回收器有哪些>3. JVM 垃圾回收器有哪些？<a href=#3-jvm-垃圾回收器有哪些 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Serial、Parallel、CMS、G1、ZGC、Shenandoah 等。</p><h3 id=4-minor-gc-和-full-gc-的区别>4. Minor GC 和 Full GC 的区别？<a href=#4-minor-gc-和-full-gc-的区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Minor GC 发生在新生代，速度快。</li><li>Full GC 会回收整个堆，包括老年代，速度慢。</li></ul><h3 id=5-判断对象是否可以被-gc-回收的依据>5. 判断对象是否可以被 GC 回收的依据？<a href=#5-判断对象是否可以被-gc-回收的依据 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>引用计数法、可达性分析算法（GC Roots）。</p><h3 id=6-java-中的强软弱虚引用>6. Java 中的强、软、弱、虚引用？<a href=#6-java-中的强软弱虚引用 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>强引用：默认引用类型。</li><li>软引用：内存不足时回收。</li><li>弱引用：下一次 GC 时就回收。</li><li>虚引用：仅用于追踪对象是否被 GC。</li></ul><h3 id=7-如何查看-java-堆栈信息>7. 如何查看 Java 堆栈信息？<a href=#7-如何查看-java-堆栈信息 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>使用 jps、jstack、jmap、VisualVM 工具。</p><h3 id=8-内存泄漏和内存溢出的区别>8. 内存泄漏和内存溢出的区别？<a href=#8-内存泄漏和内存溢出的区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>泄漏：对象不再使用但未被回收。</li><li>溢出：申请的内存超出最大限制。</li></ul><h3 id=9-方法区和堆的区别>9. 方法区和堆的区别？<a href=#9-方法区和堆的区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>堆存放实例对象。</li><li>方法区（元空间）存储类结构、常量池等。</li></ul><h3 id=10-jvm-调优常用参数>10. JVM 调优常用参数？<a href=#10-jvm-调优常用参数 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>如 <code>-Xms</code>, <code>-Xmx</code>, <code>-XX:+UseG1GC</code> 等。</p><hr><h2 id=模块三多线程与并发共-10-题>模块三：多线程与并发（共 10 题）<a href=#模块三多线程与并发共-10-题 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=1-创建线程的方式有哪些>1. 创建线程的方式有哪些？<a href=#1-创建线程的方式有哪些 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>继承 Thread 类、实现 Runnable 接口、实现 Callable 接口。</p><h3 id=2-synchronized-的作用>2. synchronized 的作用？<a href=#2-synchronized-的作用 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>可用于修饰方法或代码块，确保线程安全。</p><h3 id=3-volatile-的作用>3. volatile 的作用？<a href=#3-volatile-的作用 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>保证变量的可见性，不保证原子性。</p><h3 id=4-什么是线程死锁如何避免>4. 什么是线程死锁？如何避免？<a href=#4-什么是线程死锁如何避免 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>多个线程互相等待资源，避免策略包括锁顺序、定时锁、死锁检测机制等。</p><h3 id=5-threadlocal-的作用>5. ThreadLocal 的作用？<a href=#5-threadlocal-的作用 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>为每个线程提供独立的变量副本，适用于线程封闭。</p><h3 id=6-线程池的构造参数>6. 线程池的构造参数？<a href=#6-线程池的构造参数 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>corePoolSize、maximumPoolSize、keepAliveTime、workQueue、threadFactory、handler。</p><h3 id=7-java-并发包-juc-有哪些工具类>7. Java 并发包 J.U.C 有哪些工具类？<a href=#7-java-并发包-juc-有哪些工具类 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>CountDownLatch、CyclicBarrier、Semaphore、ReentrantLock、BlockingQueue、Atomic 系列类等。</p><h3 id=8-cas-是什么>8. CAS 是什么？<a href=#8-cas-是什么 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>比较并交换，无锁并发的核心，原子性操作的基础。</p><h3 id=9-什么是-aqs>9. 什么是 AQS？<a href=#9-什么是-aqs class=hanchor arialabel=Anchor>&#8983;</a></h3><p>AbstractQueuedSynchronizer，用于构建锁和同步器的框架。</p><h3 id=10-java-中的锁有哪些>10. Java 中的锁有哪些？<a href=#10-java-中的锁有哪些 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>公平锁/非公平锁、可重入锁、读写锁、偏向锁、轻量级锁、重量级锁。</p><hr><h2 id=模块四spring--spring-boot共-10-题>模块四：Spring & Spring Boot（共 10 题）<a href=#模块四spring--spring-boot共-10-题 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=1-spring-的核心模块有哪些>1. Spring 的核心模块有哪些？<a href=#1-spring-的核心模块有哪些 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Core、Context、Beans、AOP、Web、ORM 等。</p><h3 id=2-spring-bean-生命周期>2. Spring Bean 生命周期？<a href=#2-spring-bean-生命周期 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>实例化 -> 设置属性 -> 初始化（@PostConstruct）-> 使用 -> 销毁（@PreDestroy）。</p><h3 id=3-ioc-和-di-是什么>3. IoC 和 DI 是什么？<a href=#3-ioc-和-di-是什么 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>IoC：控制反转。</li><li>DI：依赖注入，是实现 IoC 的一种方式。</li></ul><h3 id=4-aop-实现原理>4. AOP 实现原理？<a href=#4-aop-实现原理 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>基于动态代理（JDK、CGLIB）实现横切逻辑。</p><h3 id=5-spring-boot-的自动配置原理>5. Spring Boot 的自动配置原理？<a href=#5-spring-boot-的自动配置原理 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>基于 @EnableAutoConfiguration 和 META-INF/spring.factories。</p><h3 id=6-autowired-和-resource-区别>6. @Autowired 和 @Resource 区别？<a href=#6-autowired-和-resource-区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>@Autowired：按类型注入。</li><li>@Resource：按名称注入。</li></ul><h3 id=7-spring-常见注解>7. Spring 常见注解？<a href=#7-spring-常见注解 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>@Component、@Service、@Repository、@Controller、@RestController、@Bean、@Configuration。</p><h3 id=8-spring-mvc-请求流程>8. Spring MVC 请求流程？<a href=#8-spring-mvc-请求流程 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>DispatcherServlet -> HandlerMapping -> Controller -> ViewResolver。</p><h3 id=9-spring-中的事务管理>9. Spring 中的事务管理？<a href=#9-spring-中的事务管理 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>使用 @Transactional，支持声明式和编程式事务。</p><h3 id=10-如何排查-spring-启动失败>10. 如何排查 Spring 启动失败？<a href=#10-如何排查-spring-启动失败 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>查看日志、排查依赖冲突、使用 <code>--debug</code> 模式。</p><hr><h2 id=模块五数据库与缓存共-10-题>模块五：数据库与缓存（共 10 题）<a href=#模块五数据库与缓存共-10-题 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=1-索引的底层原理>1. 索引的底层原理？<a href=#1-索引的底层原理 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>一般使用 B+ 树，便于范围查询和排序。</p><h3 id=2-主键索引和普通索引区别>2. 主键索引和普通索引区别？<a href=#2-主键索引和普通索引区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>主键索引唯一且不能为 null，普通索引可重复。</p><h3 id=3-redis-常见数据结构>3. Redis 常见数据结构？<a href=#3-redis-常见数据结构 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>String、List、Set、ZSet、Hash、Bitmap、HyperLogLog。</p><h3 id=4-redis-过期策略>4. Redis 过期策略？<a href=#4-redis-过期策略 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>定时删除、惰性删除、定期删除。</p><h3 id=5-redis-缓存雪崩击穿穿透>5. Redis 缓存雪崩、击穿、穿透？<a href=#5-redis-缓存雪崩击穿穿透 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>雪崩：大量 key 同时失效。</li><li>击穿：热点 key 失效。</li><li>穿透：请求不存在的数据。</li></ul><h3 id=6-mysql-的事务隔离级别>6. MySQL 的事务隔离级别？<a href=#6-mysql-的事务隔离级别 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Read Uncommitted、Read Committed、Repeatable Read、Serializable。</p><h3 id=7-innodb-和-myisam-区别>7. InnoDB 和 MyISAM 区别？<a href=#7-innodb-和-myisam-区别 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>InnoDB 支持事务和外键，支持行级锁。</li><li>MyISAM 不支持事务，锁粒度较大。</li></ul><h3 id=8-redis-持久化方式>8. Redis 持久化方式？<a href=#8-redis-持久化方式 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>RDB（快照）、AOF（追加日志）、混合持久化。</p><h3 id=9-什么是慢查询如何优化>9. 什么是慢查询？如何优化？<a href=#9-什么是慢查询如何优化 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>执行时间超过指定阈值的 SQL，可通过索引、优化 SQL、加缓存等方法优化。</p><h3 id=10-分库分表的常见策略>10. 分库分表的常见策略？<a href=#10-分库分表的常见策略 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>按用户 ID 哈希、时间分表、水平垂直分拆等。</p><hr><h2 id=模块六分布式系统设计共-10-题>模块六：分布式系统设计（共 10 题）<a href=#模块六分布式系统设计共-10-题 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=1-什么是微服务架构>1. 什么是微服务架构？<a href=#1-什么是微服务架构 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>将单体应用拆分为多个小型服务，通过接口进行通信。</p><h3 id=2-常见的注册中心有哪些>2. 常见的注册中心有哪些？<a href=#2-常见的注册中心有哪些 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Eureka、Consul、Zookeeper、Nacos。</p><h3 id=3-分布式系统中的一致性问题如何解决>3. 分布式系统中的一致性问题如何解决？<a href=#3-分布式系统中的一致性问题如何解决 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>使用分布式事务、最终一致性、幂等性处理。</p><h3 id=4-分布式锁的实现方式>4. 分布式锁的实现方式？<a href=#4-分布式锁的实现方式 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>基于 Redis（SETNX + EX）、Zookeeper（临时顺序节点）。</p><h3 id=5-什么是服务雪崩如何避免>5. 什么是服务雪崩？如何避免？<a href=#5-什么是服务雪崩如何避免 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>服务依赖失败导致系统整体崩溃，可通过熔断、限流、降级机制避免。</p><h3 id=6-cap-原理与-base-理论>6. CAP 原理与 BASE 理论？<a href=#6-cap-原理与-base-理论 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>CAP：一致性、可用性、分区容忍性。</li><li>BASE：基本可用、软状态、最终一致性。</li></ul><h3 id=7-常见的服务调用方式>7. 常见的服务调用方式？<a href=#7-常见的服务调用方式 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>REST、RPC（如 Dubbo、gRPC）、消息队列异步调用。</p><h3 id=8-微服务的配置管理怎么做>8. 微服务的配置管理怎么做？<a href=#8-微服务的配置管理怎么做 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>使用 Nacos、Apollo、Spring Cloud Config 等。</p><h3 id=9-网关的作用和常见实现>9. 网关的作用和常见实现？<a href=#9-网关的作用和常见实现 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>统一入口、安全认证、路由转发，如 Nginx、Spring Cloud Gateway。</p><h3 id=10-如何实现链路追踪>10. 如何实现链路追踪？<a href=#10-如何实现链路追踪 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>使用 Sleuth、Zipkin、SkyWalking、Jaeger 等组件。</p><hr><p><strong>提示：</strong> 本题库适用于笔试、自测、面试准备，也适合整理为答题卡和知识地图。</p><h1 id=java开发面试题库>Java开发面试题库<a href=#java开发面试题库 class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=一java基础>一、Java基础<a href=#一java基础 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=-基础语法>✅ 基础语法<a href=#-基础语法 class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>Q: Java中==与equals的区别？</strong>
A: <code>==</code> 比较的是两个对象的引用地址是否相同，<code>equals()</code> 比较的是对象的内容是否相同（前提是该类重写了equals方法）。</p><p><strong>Q: String为什么是不可变的？</strong>
A: 因为String类被final修饰，内部字符数组也是final，且没有提供修改的方法，这样可以保证安全性、线程安全，并能用于常量池优化。</p><p><strong>Q: String、StringBuilder、StringBuffer的区别？</strong>
A:</p><ul><li>String：不可变，适合少量拼接。</li><li>StringBuilder：可变，单线程高效。</li><li>StringBuffer：可变，线程安全但效率较低。</li></ul><p><strong>Q: 抽象类与接口的区别？</strong>
A:</p><ul><li>抽象类可以包含成员变量和构造函数；接口只能有常量。</li><li>一个类只能继承一个抽象类，但可以实现多个接口。</li><li>接口更侧重于行为约定，抽象类是类层次结构的一部分。</li></ul><p><strong>Q: final关键字的使用场景？</strong>
A:</p><ul><li>final变量：不可被重新赋值。</li><li>final方法：不可被子类重写。</li><li>final类：不可被继承。</li></ul><h2 id=二集合框架>二、集合框架<a href=#二集合框架 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>Q: HashMap的底层实现？</strong>
A: 底层由数组 + 链表/红黑树组成。Java 8之后，当链表长度超过8时转为红黑树。</p><p><strong>Q: ConcurrentHashMap如何实现线程安全？</strong>
A: Java 8中使用 CAS + synchronized 实现分段锁保护节点，提高并发性能。</p><p><strong>Q: Set如何保证元素不重复？</strong>
A: 依赖元素的 <code>hashCode()</code> 和 <code>equals()</code> 方法判断重复。</p><h2 id=三并发编程>三、并发编程<a href=#三并发编程 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>Q: volatile关键字的原理与使用？</strong>
A: 保证可见性，禁止指令重排序，不保证原子性。适用于状态标志。</p><p><strong>Q: 死锁产生的条件及解决办法？</strong>
A: 四个条件：互斥、不可剥夺、请求与保持、循环等待。
解决方案：打破其中一个条件，例如通过资源顺序获取避免循环等待。</p><p><strong>Q: ThreadLocal作用与底层原理？</strong>
A: 为每个线程提供独立变量副本。底层通过Thread类中的ThreadLocalMap实现。</p><h2 id=四jvm与性能优化>四、JVM与性能优化<a href=#四jvm与性能优化 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>Q: JVM内存结构？</strong>
A: 包括程序计数器、虚拟机栈、本地方法栈、堆、方法区。</p><p><strong>Q: Minor GC与Full GC区别？</strong>
A: Minor GC主要回收新生代，Full GC会回收整个堆（包括老年代）与方法区，开销更大。</p><h2 id=五spring相关>五、Spring相关<a href=#五spring相关 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>Q: Bean的生命周期？</strong>
A: 实例化 -> 设置属性 -> BeanNameAware -> BeanFactoryAware -> PostConstruct -> InitializingBean -> 自定义init方法 -> 使用 -> PreDestroy -> DisposableBean -> 自定义destroy方法。</p><p><strong>Q: Spring的AOP底层实现？</strong>
A: 基于动态代理（JDK Proxy 或 CGLIB），使用切点表达式和通知方法完成横切逻辑织入。</p><h2 id=六数据库与mybatis>六、数据库与MyBatis<a href=#六数据库与mybatis class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>Q: MySQL索引底层结构？</strong>
A: 使用B+树结构，叶子节点存储数据，所有查询都从根节点向下查找。</p><p><strong>Q: #{} 和 ${} 的区别？</strong>
A: <code>#{}</code>是预编译处理，防止SQL注入；<code>${}</code>是字符串拼接，可能会有注入风险。</p><h2 id=七网络与分布式>七、网络与分布式<a href=#七网络与分布式 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>Q: TCP三次握手过程？</strong>
A:</p><ol><li>客户端发送SYN请求；</li><li>服务器返回SYN+ACK；</li><li>客户端发送ACK，连接建立。</li></ol><p><strong>Q: CAP理论解释？</strong>
A: 一致性（C）、可用性（A）、分区容错性（P），在分布式系统中三者不可兼得，只能选择其中两者优先。</p><p><strong>Q: 分布式锁的实现方式？</strong>
A:</p><ul><li>基于数据库（悲观锁）</li><li>Redis实现：setnx + 过期时间</li><li>ZooKeeper临时顺序节点</li></ul><h2 id=八项目经验相关>八、项目经验相关<a href=#八项目经验相关 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>Q: 项目中遇到的最大挑战是什么？</strong>
A: 举例：高并发下系统响应慢，采用缓存+异步队列+数据库优化方式解决，响应速度提升50%。</p><hr><blockquote><p>建议：熟练掌握每个问题的底层原理和应用场景，在面试中主动引导话题更容易脱颖而出。</p></blockquote></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://connorzhangyu.com/posts/go%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/><span class=button__icon>←</span>
<span class=button__text>Go学习计划</span>
</a></span><span class="button next"><a href=https://connorzhangyu.com/posts/axure/><span class=button__text>Axure</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>