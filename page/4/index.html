<!doctype html><html lang=zh><head><meta name=generator content="Hugo 0.148.2"><title>Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="记仇小本本"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=../../><link rel=stylesheet href=../../styles.css><link rel="shortcut icon" href=../../img/theme-colors/orange.png><link rel=apple-touch-icon href=../../img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:title" content="Hello World"><meta property="og:description" content="记仇小本本"><meta property="og:url" content="/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=../../index.xml rel=alternate type=application/rss+xml title="Hello World"><link href=../../index.json rel=alternate type=application/json title="Hello World"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=../../><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=../../about>关于</a></li><li><a href=../../showcase>精选</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=../../posts/network/>netWork</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=网络>网络</h1><h2 id=http-响应码-301-和-302-代表的是什么有什么区别>http 响应码 301 和 302 代表的是什么？有什么区别？</h2><p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。
区别：<br>301 redirect: 301 代表永久性转移(Permanently Moved)。<br>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</p><h2 id=forward-和-redirect-的区别>forward 和 redirect 的区别？</h2><p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。<br>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。<br>间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。<br>举个通俗的例子：<br>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；<br>间接转发就相当于：&ldquo;A找B借钱，B说没有，让A去找C借&rdquo;。</p><h2 id=简述-tcp-和-udp的区别>简述 tcp 和 udp的区别？</h2><p>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。<br>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。<br>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。<br>TCP对系统资源要求较多，UDP对系统资源要求较少。</p><h2 id=tcp-为什么要三次握手两次不行吗为什么>tcp 为什么要三次握手，两次不行吗？为什么？</h2><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。<br>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p><h2 id=说一下-tcp-粘包是怎么产生的>说一下 tcp 粘包是怎么产生的？</h2><ol><li>发送方产生粘包<br>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/318149a77d9db39b6f6fe8ef19e04e3ee57d4be611231e3dcff1d419f08a16e73ca6db3e3e6704e5df370cad7d819799?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=495869333&amp;fname=%E5%8F%91%E9%80%81%E6%96%B9%E4%BA%A7%E7%94%9F%E7%B2%98%E5%8C%85.png&amp;size=750" alt=发送方产生粘包></li><li>接收方产生粘包<br>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/7a0e63ec64ac934f6c244db8d8a78ab3b5b379520c665ee162b4fdf1b9006901794b322fd8fb394ba7c32d45fcedd3e6?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=495869333&amp;fname=%E6%8E%A5%E6%94%B6%E6%96%B9%E4%BA%A7%E7%94%9F%E7%B2%98%E5%8C%85.png&amp;size=750" alt=接收方产生粘包></li></ol><h2 id=osi-的七层模型都有哪些>OSI 的七层模型都有哪些？</h2><ol><li>应用层：网络服务与最终用户的一个接口。</li><li>表示层：数据的表示、安全、压缩。</li><li>会话层：建立、管理、终止会话。</li><li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li><li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li><li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li><li>物理层：建立、维护、断开物理连接。</li></ol><h2 id=get-和-post-请求有哪些区别>get 和 post 请求有哪些区别？</h2><p>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET产生的URL地址可以被Bookmark，而POST不可以。<br>GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中。</p></div><div><a class="read-more button" href=../../posts/network/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=../../posts/reflection/>reflection</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=反射>反射</h1><h2 id=什么是反射>什么是反射？</h2><p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力<br>Java反射：<br>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法<br>Java反射机制主要提供了以下功能：<br>在运行时判断任意一个对象所属的类。<br>在运行时构造任意一个类的对象。<br>在运行时判断任意一个类所具有的成员变量和方法。<br>在运行时调用任意一个对象的方法。</p><h2 id=什么是-java-序列化什么情况下需要序列化>什么是 java 序列化？什么情况下需要序列化？</h2><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。<br>什么情况下需要序列化：</p><ol><li>当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>当你想用套接字在网络上传送对象的时候；</li><li>当你想通过RMI传输对象的时候；</li></ol><h2 id=动态代理是什么有哪些应用>动态代理是什么？有哪些应用？</h2><p>动态代理：<br>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。<br>动态代理的应用：<br>Spring的AOP<br>加事务<br>加权限<br>加日志</p><h2 id=怎么实现动态代理>怎么实现动态代理？</h2><p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p><h2 id=目录>目录</h2><ul><li><a href=../../java/javaBase.md>Java基础</a></li><li><a href=../../java/collection.md>容器</a></li><li><a href=../../java/thread.md>线程</a></li><li><a href=../../java/reflection.md>反射</a></li><li><a href=../../java/cloneable.md>对象克隆</a></li><li><a href=../../java/javaWeb.md>JavaWeb</a></li><li><a href=../../java/exception.md>异常</a></li><li><a href=../../java/netWork.md>网络服务</a></li><li><a href=../../java/designpattern.md>设计模式</a></li><li><a href=../../java/spring.md>Spring</a></li><li><a href=../../java/springMVC.md>Spring MVC</a></li><li><a href=../../java/springBoot.md>Spring Boot</a></li><li><a href=../../java/springCloud.md>Spring Cloud</a></li><li><a href=../../java/hibernate.md>Hibernate</a></li><li><a href=../../java/mybatis.md>Mybatis</a></li><li><a href=../../java/mq.md>队列</a></li><li><a href=../../java/zookeeper.md>Zookeeper</a></li><li><a href=../../java/mySql.md>MySql</a></li><li><a href=../../java/redis.md>Redis</a></li><li><a href=../../java/jvm.md>Jvm</a></li></ul></div><div><a class="read-more button" href=../../posts/reflection/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=../../posts/springmvc/>springMVC</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=spring-mvc>Spring MVC</h1><h2 id=说一下-spring-mvc-运行流程>说一下 spring mvc 运行流程？</h2><p>Spring MVC运行流程图：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/d1f3cfcfacc0c82aa4f6870eaca54d649c6b8358aaff78b9ffa1413397124e3f1c0ec0ad425d6fe651ce7a7e1ee52520?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=495869333&amp;fname=springMVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png&amp;size=750" alt="Spring MVC运行流程图"></p><p>Spring运行流程描述：</p><ol><li>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</li><li>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</li><li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(&mldr;)方法）</li><li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：<br>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息<br>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等<br>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等<br>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li><li>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</li><li>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</li><li>ViewResolver 结合Model和View，来渲染视图；</li><li>将渲染结果返回给客户端。</li></ol><h2 id=spring-mvc-有哪些组件>spring mvc 有哪些组件？</h2><p>Spring MVC的核心组件：<br>DispatcherServlet：中央控制器，把请求给转发到具体的控制类<br>Controller：具体处理请求的控制器<br>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略<br>ModelAndView：服务层返回的数据和视图层的封装类<br>ViewResolver：视图解析器，解析具体的视图<br>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</p><h2 id=controller和restcontroller的区别>@Controller和@RestController的区别?</h2><ol><li><p>Controller, RestController的共同点
都是用来表示Spring某个类的是否可以接收HTTP请求</p></li><li><p>Controller, RestController的不同点<br>@Controller标识一个Spring类是Spring MVC controller处理器<br>@RestController：@RestController是@Controller和@ResponseBody的结合体，两个标注合并起来的作用。</p></li></ol><p>3、如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。<br>例如：本来应该到success.jsp页面的，则其显示success.</p><p>4、如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。</p><p>5、如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。</p><h2 id=requestbody-responsebody-的作用>@RequestBody @ResponseBody 的作用</h2><h3 id=requestbody>@RequestBody</h3><ol><li>作用：
该注解用于读取 Request 请求的 body 部分数据，使用系统默认配置的 HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上；
再把 HttpMessageConverter 返回的对象数据绑定到 controller 中方法的参数上。</li><li>使用时机：
GET、POST方式提交时， 根据 request header Content-Type 的值来判断:
application/x-www-form-urlencoded：可选（即非必须，因为这种情况的数据 @RequestParam, @ModelAttribute 也可以处理，当然@RequestBody也能处理）；
multipart/form-data：不能处理（即使用@RequestBody不能处理这种格式的数据）；
其他格式：必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；
PUT 方式提交时， 根据request header Content-Type的值来判断:
application/x-www-form-urlencoded：必须；
multipart/form-data：不能处理；
其他格式：必须；</li></ol><p>作者：希希里之海
链接：https://www.jianshu.com/p/64b22da6c9ab
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><div><a class="read-more button" href=../../posts/springmvc/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=../../posts/thread/>thread</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=线程>线程</h1><h2 id=并行和并发有什么区别>并行和并发有什么区别？</h2><p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。<br>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><h2 id=线程和进程的区别>线程和进程的区别？</h2><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p><h2 id=守护线程是什么>守护线程是什么？</h2><p>守护线程（即daemon thread），是个服务线程，准确地来说就是务服其他的线程。</p><h2 id=创建线程有哪几种方式>创建线程有哪几种方式？</h2><ol><li>继承Thread类创建线程类<br>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>创建Thread子类的实例，即创建了线程对象。<br>调用线程对象的start()方法来启动该线程。</li><li>通过Runnable接口创建线程类<br>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>调用线程对象的start()方法来启动该线程。</li><li>通过Callable和Future创建线程<br>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li></ol><h2 id=说一下-runnable-和-callable-有什么区别>说一下 runnable 和 callable 有什么区别？</h2><p>有点深的问题了，也看出一个Java程序员学习知识的广度。<br>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；<br>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><h2 id=线程有哪些状态>线程有哪些状态？</h2><p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。<br>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪</p><h2 id=sleep-和-wait-有什么区别>sleep() 和 wait() 有什么区别？</h2><p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。<br>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p><h2 id=notify和-notifyall有什么区别>notify()和 notifyAll()有什么区别？</h2><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。<br>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p><h2 id=线程的-run和-start有什么区别>线程的 run()和 start()有什么区别？</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。<br>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p></div><div><a class="read-more button" href=../../posts/thread/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=../../posts/zookeeper/>zookeeper</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=zookeeper>Zookeeper</h1><h2 id=zookeeper-是什么>zookeeper 是什么？</h2><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><h2 id=zookeeper-都有哪些功能>zookeeper 都有哪些功能？</h2><p>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p><h2 id=zookeeper-有几种部署模式>zookeeper 有几种部署模式？</h2><p>zookeeper 有三种部署模式：</p><ol><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li></ol><h2 id=zookeeper-怎么保证主从节点的状态同步>zookeeper 怎么保证主从节点的状态同步？</h2><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h2 id=集群中为什么要有主节点>集群中为什么要有主节点？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h2 id=集群中有-3-台服务器其中一个节点宕机这个时候-zookeeper-还可以使用吗>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h2><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><h2 id=说一下-zookeeper-的通知机制>说一下 zookeeper 的通知机制？</h2><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p></div><div><a class="read-more button" href=../../posts/zookeeper/>Read more →</a></div></article><div class=pagination><div class=pagination__buttons><a href=../../page/3/ class="button previous"><span class=button__icon>←</span>
<span class=button__text>Newer posts</span>
</a><a href=../../page/5/ class="button next"><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=../../bundle.min.js></script></div></body></html>