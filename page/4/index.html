<!doctype html><html lang=zh><head><meta name=generator content="Hugo 0.148.2"><title>Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="记仇小本本"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://connorzhangyu.com/><link rel=stylesheet href=https://connorzhangyu.com/styles.css><link rel="shortcut icon" href=https://connorzhangyu.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://connorzhangyu.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:title" content="Hello World"><meta property="og:description" content="记仇小本本"><meta property="og:url" content="https://connorzhangyu.com/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="https://connorzhangyu.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/index.xml rel=alternate type=application/rss+xml title="Hello World"><link href=/index.json rel=alternate type=application/json title="Hello World"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/thread/>thread</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=线程>线程</h1><h2 id=并行和并发有什么区别>并行和并发有什么区别？</h2><p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。<br>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><h2 id=线程和进程的区别>线程和进程的区别？</h2><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p><h2 id=守护线程是什么>守护线程是什么？</h2><p>守护线程（即daemon thread），是个服务线程，准确地来说就是务服其他的线程。</p><h2 id=创建线程有哪几种方式>创建线程有哪几种方式？</h2><ol><li>继承Thread类创建线程类<br>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>创建Thread子类的实例，即创建了线程对象。<br>调用线程对象的start()方法来启动该线程。</li><li>通过Runnable接口创建线程类<br>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>调用线程对象的start()方法来启动该线程。</li><li>通过Callable和Future创建线程<br>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li></ol><h2 id=说一下-runnable-和-callable-有什么区别>说一下 runnable 和 callable 有什么区别？</h2><p>有点深的问题了，也看出一个Java程序员学习知识的广度。<br>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；<br>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><h2 id=线程有哪些状态>线程有哪些状态？</h2><p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。<br>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪</p><h2 id=sleep-和-wait-有什么区别>sleep() 和 wait() 有什么区别？</h2><p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。<br>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p><h2 id=notify和-notifyall有什么区别>notify()和 notifyAll()有什么区别？</h2><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。<br>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p><h2 id=线程的-run和-start有什么区别>线程的 run()和 start()有什么区别？</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。<br>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p></div><div><a class="read-more button" href=/posts/thread/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/zookeeper/>zookeeper</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=zookeeper>Zookeeper</h1><h2 id=zookeeper-是什么>zookeeper 是什么？</h2><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><h2 id=zookeeper-都有哪些功能>zookeeper 都有哪些功能？</h2><p>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p><h2 id=zookeeper-有几种部署模式>zookeeper 有几种部署模式？</h2><p>zookeeper 有三种部署模式：</p><ol><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li></ol><h2 id=zookeeper-怎么保证主从节点的状态同步>zookeeper 怎么保证主从节点的状态同步？</h2><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h2 id=集群中为什么要有主节点>集群中为什么要有主节点？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h2 id=集群中有-3-台服务器其中一个节点宕机这个时候-zookeeper-还可以使用吗>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h2><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><h2 id=说一下-zookeeper-的通知机制>说一下 zookeeper 的通知机制？</h2><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p></div><div><a class="read-more button" href=/posts/zookeeper/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/cloneable/>cloneable</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=对象克隆>对象克隆</h1><h2 id=为什么要使用克隆>为什么要使用克隆？</h2><p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p><h2 id=如何实现对象克隆>如何实现对象克隆？</h2><p>有两种方式：<br>1). 实现Cloneable接口并重写Object类中的clone()方法；<br>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.ByteArrayInputStream;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.ByteArrayOutputStream;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.ObjectInputStream;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.ObjectOutputStream;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.Serializable;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyUtil</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>MyUtil</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> AssertionError();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;unchecked&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T <span style=color:#66d9ef>extends</span> Serializable<span style=color:#f92672>&gt;</span> T <span style=color:#a6e22e>clone</span>(T obj) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        ByteArrayOutputStream bout <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayOutputStream();
</span></span><span style=display:flex><span>        ObjectOutputStream oos <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectOutputStream(bout);
</span></span><span style=display:flex><span>        oos.<span style=color:#a6e22e>writeObject</span>(obj);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ByteArrayInputStream bin <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayInputStream(bout.<span style=color:#a6e22e>toByteArray</span>());
</span></span><span style=display:flex><span>        ObjectInputStream ois <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectInputStream(bin);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (T) ois.<span style=color:#a6e22e>readObject</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面是测试代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.Serializable;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 人类
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @author nnngu
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>implements</span> Serializable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> serialVersionUID <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>9102017020286042305L;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;    <span style=color:#75715e>// 姓名</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;        <span style=color:#75715e>// 年龄</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Car car;        <span style=color:#75715e>// 座驾</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age, Car car) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>car</span> <span style=color:#f92672>=</span> car;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span>(<span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Car <span style=color:#a6e22e>getCar</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> car;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setCar</span>(Car car) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>car</span> <span style=color:#f92672>=</span> car;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Person [name=&#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, age=&#34;</span> <span style=color:#f92672>+</span> age <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, car=&#34;</span> <span style=color:#f92672>+</span> car <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 小汽车类
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @author nnngu
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Car</span> <span style=color:#66d9ef>implements</span> Serializable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> serialVersionUID <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>5713945027627603702L;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String brand;       <span style=color:#75715e>// 品牌</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> maxSpeed;       <span style=color:#75715e>// 最高时速</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Car</span>(String brand, <span style=color:#66d9ef>int</span> maxSpeed) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>brand</span> <span style=color:#f92672>=</span> brand;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>maxSpeed</span> <span style=color:#f92672>=</span> maxSpeed;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getBrand</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> brand;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setBrand</span>(String brand) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>brand</span> <span style=color:#f92672>=</span> brand;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getMaxSpeed</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> maxSpeed;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setMaxSpeed</span>(<span style=color:#66d9ef>int</span> maxSpeed) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>maxSpeed</span> <span style=color:#f92672>=</span> maxSpeed;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Car [brand=&#34;</span> <span style=color:#f92672>+</span> brand <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, maxSpeed=&#34;</span> <span style=color:#f92672>+</span> maxSpeed <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CloneTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            Person p1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;郭靖&#34;</span>, 33, <span style=color:#66d9ef>new</span> Car(<span style=color:#e6db74>&#34;Benz&#34;</span>, 300));
</span></span><span style=display:flex><span>            Person p2 <span style=color:#f92672>=</span> MyUtil.<span style=color:#a6e22e>clone</span>(p1);   <span style=color:#75715e>// 深度克隆</span>
</span></span><span style=display:flex><span>            p2.<span style=color:#a6e22e>getCar</span>().<span style=color:#a6e22e>setBrand</span>(<span style=color:#e6db74>&#34;BYD&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 修改克隆的Person对象p2关联的汽车对象的品牌属性</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 原来的Person对象p1关联的汽车不会受到任何影响</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 因为在克隆Person对象时其关联的汽车对象也被克隆了</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p1);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p></div><div><a class="read-more button" href=/posts/cloneable/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/collection/>collection</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=容器>容器</h1><h2 id=java-容器都有哪些>java 容器都有哪些？</h2><p>常用容器的图录：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/50db8810cd8a2e8038518950609a4e70a630e0f634e152308a104b665732101c6f98885b0382fadfdf7bd7827237a7b9?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=495869333&amp;fname=%E5%AE%B9%E5%99%A8.png&amp;size=750" alt=容器></p><h2 id=collection-和-collections-有什么区别>Collection 和 Collections 有什么区别？</h2><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。<br>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p><h2 id=listsetmap-之间的区别是什么>List、Set、Map 之间的区别是什么？</h2><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/53645c0581237e3d85c558727d8943685fb28c22aaac3b1dc797a30cb39da13f988fc08da23117883268da5d5a0470b7?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=495869333&amp;fname=List-Set-Map%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.png&amp;size=750" alt=List-Set-Map之间的区别></p><h2 id=hashmap-和-hashtable-有什么区别>HashMap 和 Hashtable 有什么区别？</h2><p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。<br>hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。<br>hashMap允许空键值，而hashTable不允许。</p><h2 id=如何决定使用-hashmap-还是-treemap>如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。<br>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。<br>基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h2 id=说一下-hashmap-的实现原理>说一下 HashMap 的实现原理？</h2><p>HashMap概述：<br>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap的数据结构：<br>在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根据hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。<br>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p><h2 id=说一下-hashset-的实现原理>说一下 HashSet 的实现原理？</h2><p>HashSet底层由HashMap实现<br>HashSet的值存放于HashMap的key上<br>HashMap的value统一为PRESENT</p><h2 id=arraylist-和-linkedlist-的区别是什么>ArrayList 和 LinkedList 的区别是什么？</h2><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p><h2 id=如何实现数组和-list-之间的转换>如何实现数组和 List 之间的转换？</h2><p>List转换成为数组：调用ArrayList的toArray方法。<br>数组转换成为List：调用Arrays的asList方法。</p><h2 id=arraylist-和-vector-的区别是什么>ArrayList 和 Vector 的区别是什么？</h2><p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。<br>ArrayList比Vector快，它因为有同步，不会过载。<br>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p></div><div><a class="read-more button" href=/posts/collection/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/designpattern/>designpattern</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=设计模式>设计模式</h1><h2 id=说一下你熟悉的设计模式>说一下你熟悉的设计模式？</h2><h2 id=单例模式>单例模式</h2><p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p><p>getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看demo吧</p><h2 id=基本写法>基本写法</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton singleton;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (singleton <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        singleton <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> singleton;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>按照我的习惯，我恨不得写满注释，怕你们看不懂，但是这个代码实在太简单了，所以我没写任何注释，如果这几行代码你都看不明白的话，那你可以洗洗睡了，等你睡醒了再来看我的博客说不定能看懂。</p><p>上面的是最基本的写法，也叫懒汉写法（线程不安全）下面我再公布几种单例模式的写法：</p><h2 id=懒汉式写法线程安全>懒汉式写法（线程安全）</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton instance;  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span> (){}  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> Singleton <span style=color:#a6e22e>getInstance</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {  
</span></span><span style=display:flex><span>       instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton();  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> instance;  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=饿汉式写法>饿汉式写法</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton();  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span> (){}  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> instance;  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=静态内部类>静态内部类</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingletonHolder</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Singleton INSTANCE <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton();  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span> (){}  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Singleton <span style=color:#a6e22e>getInstance</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> SingletonHolder.<span style=color:#a6e22e>INSTANCE</span>;  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=枚举>枚举</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> Singleton {  
</span></span><span style=display:flex><span>   INSTANCE;  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>whateverMethod</span>() {  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏。</p></div><div><a class="read-more button" href=/posts/designpattern/>Read more →</a></div></article><div class=pagination><div class=pagination__buttons><a href=/page/3/ class="button previous"><span class=button__icon>←</span>
<span class=button__text>Newer posts</span>
</a><a href=/page/5/ class="button next"><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>