<!doctype html><html lang=zh><head><meta name=generator content="Hugo 0.148.2"><title>Hello World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="记仇小本本"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://connorzhangyu.com/><link rel=stylesheet href=https://connorzhangyu.com/styles.css><link rel="shortcut icon" href=https://connorzhangyu.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://connorzhangyu.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:title" content="Hello World"><meta property="og:description" content="记仇小本本"><meta property="og:url" content="https://connorzhangyu.com/"><meta property="og:site_name" content="Hello World"><meta property="og:image" content="https://connorzhangyu.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/index.xml rel=alternate type=application/rss+xml title="Hello World"><link href=/index.json rel=alternate type=application/json title="Hello World"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>康纳的记仇小本本</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>关于</a></li><li><a href=/showcase>精选</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/designpattern/>designpattern</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=设计模式>设计模式</h1><h2 id=说一下你熟悉的设计模式>说一下你熟悉的设计模式？</h2><h2 id=单例模式>单例模式</h2><p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p><p>getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看demo吧</p><h2 id=基本写法>基本写法</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton singleton;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (singleton <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        singleton <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> singleton;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>按照我的习惯，我恨不得写满注释，怕你们看不懂，但是这个代码实在太简单了，所以我没写任何注释，如果这几行代码你都看不明白的话，那你可以洗洗睡了，等你睡醒了再来看我的博客说不定能看懂。</p><p>上面的是最基本的写法，也叫懒汉写法（线程不安全）下面我再公布几种单例模式的写法：</p><h2 id=懒汉式写法线程安全>懒汉式写法（线程安全）</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton instance;  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span> (){}  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> Singleton <span style=color:#a6e22e>getInstance</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {  
</span></span><span style=display:flex><span>       instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton();  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> instance;  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=饿汉式写法>饿汉式写法</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton();  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span> (){}  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> instance;  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=静态内部类>静态内部类</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingletonHolder</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Singleton INSTANCE <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton();  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span> (){}  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Singleton <span style=color:#a6e22e>getInstance</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> SingletonHolder.<span style=color:#a6e22e>INSTANCE</span>;  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=枚举>枚举</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> Singleton {  
</span></span><span style=display:flex><span>   INSTANCE;  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>whateverMethod</span>() {  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏。</p></div><div><a class="read-more button" href=/posts/designpattern/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/exception/>exception</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=异常>异常</h1><h2 id=throw-和-throws-的区别>throw 和 throws 的区别？</h2><p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。</p><h2 id=finalfinallyfinalize-有什么区别>final、finally、finalize 有什么区别？</h2><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。</p><h2 id=try-catch-finally-中哪个部分可以省略>try-catch-finally 中哪个部分可以省略？</h2><p>catch 可以省略<br>原因：<br>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。<br>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。<br>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p><h2 id=try-catch-finally-中如果-catch-中-return-了finally-还会执行吗>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p>会执行，在 return 前执行。<br>代码示例1：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FinallyDemo2</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getInt());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getInt</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> 10;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(a <span style=color:#f92672>/</span> 0);
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 20;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (ArithmeticException e) {
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 30;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>            <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
</span></span></span><span style=display:flex><span><span style=color:#75715e>             */</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 40;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>//      return a;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行结果：30</p></div><div><a class="read-more button" href=/posts/exception/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/hibernate/>hibernate</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=hibernate>Hibernate</h1><h2 id=为什么要使用-hibernate>为什么要使用 hibernate？</h2><p>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。<br>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作<br>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。<br>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</p><h2 id=什么是-orm-框架>什么是 ORM 框架？</h2><p>对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p><h2 id=hibernate-中如何在控制台查看打印的-sql-语句>hibernate 中如何在控制台查看打印的 sql 语句？</h2><p>参考：blog.csdn.net/Randy_Wang_/article/details/79460306</p><h2 id=打印sql语句到控制台>打印sql语句到控制台</h2><p>首先，我使用的是application.properties配置文件，使用yml也可以达到同样的效果。<br>在网上查这个问题查了好久，基本上都是xml配置，在此不多说；<br>正确的properties配置项应该如下所示：<br>在jpa下一级不直接是hibernate，而是properties。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>spring</span>:  
</span></span><span style=display:flex><span>    <span style=color:#f92672>jpa</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>properties</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>hibernate</span>:
</span></span><span style=display:flex><span>                <span style=color:#f92672>show_sql</span>: <span style=color:#ae81ff>ture                          //控制台是否打印</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>format_sql</span>: <span style=color:#66d9ef>true</span>                        <span style=color:#ae81ff>//格式化sql语句</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>use_sql_comments</span>: <span style=color:#ae81ff>ture                  //指出是什么操作生成了该语句</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>spring.jpa.properties.hibernate.show_sql=true           //控制台是否打印</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>spring.jpa.properties.hibernate.format_sql=true         //格式化sql语句</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>spring.jpa.properties.hibernate.use_sql_comments=true   //指出是什么操作生成了该语句</span>
</span></span></code></pre></div><p>此时，在控制台可以看到，控制台打印了一条经过格式化之后的sql语句，并标明了这条语句是在哪个步骤生成的。</p><h2 id=打印sql语句中的参数值>打印sql语句中的参数值</h2><p>经过上面的步骤，我们已经可以在控制台打印出格式化之后的sql语句，但是大多数情况下，我们还需要具体的sql参数值，这个时候我们就需要配置 日志配置文件。</p><p>博主使用的是slf4j的日志，配置文件用的是logback.xml，配置方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;logger</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;org.hibernate.SQL&#34;</span> <span style=color:#a6e22e>level=</span><span style=color:#e6db74>&#34;DEBUG&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;logger</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;org.hibernate.engine.QueryParameters&#34;</span> <span style=color:#a6e22e>level=</span><span style=color:#e6db74>&#34;DEBUG&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;logger</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;org.hibernate.engine.query.HQLQueryPlan&#34;</span> <span style=color:#a6e22e>level=</span><span style=color:#e6db74>&#34;DEBUG&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>直接把这三个配置丢到xml的根节点下就可以~</p><p>可以看到控制台依次输出了sql参数，并且将这些参数在数据库中的类型也一并输出了。</p><h2 id=打印sql语句到日志>打印sql语句到日志</h2><p>在上述步骤的基础上，在logback.xml中增加两项配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;logger</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;org.hibernate.type.descriptor.sql.BasicBinder&#34;</span> <span style=color:#a6e22e>level=</span><span style=color:#e6db74>&#34;TRACE&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;logger</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;org.hibernate.type.descriptor.sql.BasicExtractor&#34;</span> <span style=color:#a6e22e>level=</span><span style=color:#e6db74>&#34;TRACE&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>这样就会在日志中将sql语句打印出来，在无法查看控制台的情况下，就可以使用这个方法啦。效果如图所示：</p><p>注：</p><p>以上提到的配置如果全部配置，在控制台会有冗余的打印信息：</p><p>建议根据需要，只配置打印到控制台或打印到日志其中一种。
————————————————
版权声明：本文为CSDN博主「努力升级的小R」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Randy_Wang_/article/details/79460306</p><h2 id=hibernate-有几种查询方式>hibernate 有几种查询方式？</h2><p>Query对象查询
SQL查询<br>条件查询</p><h2 id=hql查询>HQL查询</h2><p>HQL: Hibernate Query Language. 面向对象的写法:<br>Query query = session.createQuery(&ldquo;from Customer where name = ?&rdquo;);<br>query.setParameter(0, &ldquo;苍老师&rdquo;);<br>Query.list();</p></div><div><a class="read-more button" href=/posts/hibernate/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/javabase/>javaBase</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=java-基础>Java 基础</h1><h2 id=jdk-和-jre-有什么区别>JDK 和 JRE 有什么区别？</h2><p>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。<br>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序,只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p><h2 id=-和-equals-的区别是什么>== 和 equals 的区别是什么？</h2><h2 id=-解读>== 解读</h2><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；</p><p>代码示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String x <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;string&#34;</span>;
</span></span><span style=display:flex><span>String y <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;string&#34;</span>;
</span></span><span style=display:flex><span>String z <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String(<span style=color:#e6db74>&#34;string&#34;</span>);
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(x<span style=color:#f92672>==</span>y); <span style=color:#75715e>// true</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(x<span style=color:#f92672>==</span>z); <span style=color:#75715e>// false</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(x.<span style=color:#a6e22e>equals</span>(y)); <span style=color:#75715e>// true</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(x.<span style=color:#a6e22e>equals</span>(z)); <span style=color:#75715e>// true</span>
</span></span></code></pre></div><p><strong>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</strong></p></div><div><a class="read-more button" href=/posts/javabase/>Read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://connorzhangyu.com/posts/javaweb/>javaWeb</a></h1><div class=post-meta><time class=post-date>2025-01-04</time><span class=post-author>Connor</span></div><div class=post-content><h1 id=java-web>Java Web</h1><h2 id=jsp-和-servlet-有什么区别>jsp 和 servlet 有什么区别？</h2><p>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）<br>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。<br>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。<br>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。</p><h2 id=jsp-有哪些内置对象作用分别是什么>jsp 有哪些内置对象？作用分别是什么？</h2><p>JSP有9个内置对象：<br>request：封装客户端的请求，其中包含来自GET或POST请求的参数；<br>response：封装服务器对客户端的响应；<br>pageContext：通过该对象可以获取其他对象；<br>session：封装用户会话的对象；<br>application：封装服务器运行环境的对象；<br>out：输出服务器响应的输出流对象；<br>config：Web应用的配置对象；<br>page：JSP页面本身（相当于Java程序中的this）；<br>exception：封装页面抛出异常的对象。</p><h2 id=说一下-jsp-的-4-种作用域>说一下 jsp 的 4 种作用域？</h2><p>JSP中的四种作用域包括page、request、session和application，具体来说：<br>page代表与一个页面相关的对象和属性。<br>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。<br>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。<br>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</p><h2 id=session-和-cookie-有什么区别>session 和 cookie 有什么区别？</h2><p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。<br>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。<br>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p><h2 id=说一下-session-的工作原理>说一下 session 的工作原理？</h2><p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。</p><h2 id=如果客户端禁止-cookie-能实现-session-还能用吗>如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。<br>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：<br>设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“&ndash;enable-trans-sid”选项，让PHP自动跨页传递Session ID。<br>手动通过URL传值、隐藏表单传递Session ID。<br>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</p></div><div><a class="read-more button" href=/posts/javaweb/>Read more →</a></div></article><div class=pagination><div class=pagination__buttons><a href=/page/4/ class="button previous"><span class=button__icon>←</span>
<span class=button__text>Newer posts</span>
</a><a href=/page/6/ class="button next"><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>